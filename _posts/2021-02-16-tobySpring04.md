---
title: "토비의 스프링 4장 정리 - 예외 "
date: 2021-02-16T00:42:30-04:00
categories:
  - Spring
tags:
  - Java
  - OOP
---

이 포스팅은 [토비의 스프링 3.1]의 4장 "예외"의 내용을 바탕으로 사견을 첨가해서 작성했다.

# 1. 초난감 예외처리

## 예외 블랙홀

초기의 코드를 작성하다보면 예외처리를 제대로 하지 않고 넘어가는 경우가 발생할 수 있다. IDE에서 표시되는 에러를 해결하기 위해 try~catch로 처리를 하긴 하지만, 본래의 로직 구현에만 초점이 맞춰져 있고, 예외에 대해 신경쓰지 않는 경우가 이에 해당한다.

```java
try {
...
}
catch(SQLException e) {
}
```

위의 코드처럼 예외를 잡고 아무처리 하지 않는것은 절대 만들어서는 안되는 코드다. (단, 예외 발생을 무시하고 정상적인 상황인것처럼 다음 라인으로 넘어가겠다는 분명한 의도가 있다면 상관없겠지만, 이런 의도를 갖고 코드를 짜는 상황이 있을까 싶다.)

위와 같은 코드에서는 프로그램 실행중에 어디선가 오류로 인해 예외가 발생했는데도 그것을 무시하고 계속 진행이 되버린다. 그로 인해, 어떤 기능이 비정상적으로 동작하거나, 메모리 혹은 리소스가 소진되거나, 예상치 못한 다른 문제가 발생할 것이다. 최종적으로 오작동을 하거나 시스템 오류가 나서 운영자가 알아차렸을때는 이미 조치를 취하기엔 너무 늦었다.(시스템 이상의 원인이 무엇인지 찾아내기가 매우 힘들다)

아래의 코드들도 위의 코드와 크게 다를바 없다

```java
try { ... } catch(SQLException e) {
	System.out.println(e);
}

try { ... } catch(SQLException e) {
	e.printStackTrace();
}
```

개발중에는 계획된 시나리오로 테스트를 진행하면서 콘솔창이나 터미널에서 이 메세지를 바로 확인하고 소스의 수정 및 조취를 취할 수 있다. 하지만 운영서버에선 어떨까? 누군가가 계속 콘솔 로그를 모니터링 하면서 예외를 확인할 수는 없다. 그렇기 때문에 이는 심각한 폭탄으로 남아 있을 것이다.

예외가 발생하면 적절히 처리가 돼야 하는데, 위의 방법은 그저 메세지를 출력하는것일뿐 아무 처리가 되지 않는다.

예외를 처리할 때 반드시 지켜야 할 원칙은 **"모든 예외는 적절하게 복구되든지 아니면 작업을 중단시키고 운영자 또는 개발자에게 분명하게 통보돼야 한다"** 라는 것이다.

SQLException의 경우 SQL문법 에러, 데이터 엑세스 로직에 심각한 버그 존재,  서버 다운, 네트워크 문제 등의 심각한 상황이 발생한다. 이런 경우에 예외를 무시하고 아무 문제 없는듯이 다음 코드의 실행을 이어간다는 것은 말이 되지 않는다. 콘솔이나 로그에 예외 메세지를 출력하는 건 아무 도움이 안된다.

토비님에 의하면 아무것도 안할바에 차라리 아래와 같은게 나을것이다.

```java
} catch(SQLException e) {
	e.printStackTrace();
	System.exit(1);
}
```

물론 실전에선 이렇게 하면 안된다.(sql수행중에 예외로 인해 시스템자체가 다운되는건 말이 안된다고 생각한다). 위 코드의 의도는 **예외를 무시하거나 잡아먹어 버리는 코드는 만들지 말라**는 것이다. 굳이 예외를 잡아서 뭔가 조치를 취할 방법이 없다면 잡지 말아야 한다.(메소드 선언부에 throws SQLException을 선언해서 자신을 호출한 코드에 예외처리 책임을 전가해라)

## 무의미하고 무책임한 throws

catch블록으로 예외를 잡아도 딱히 처리할 방법도 없고, JDK API나 라이브러리에서 던지는 각종 예외를 매번 throws로 선언하기 귀찮아서 아래와 같이 throws Exception을 기계적으로 붙이는 경우가 종종 있다.(예외 클래스들의 최상위 클래스인 Exception으로 몽땅 처리해버리면, 각종 상세 예외들을 일일히 나열하지 않아도 돼서 편하긴 하다)

```java

public void method1() throws Exception {
	method2();
}

public void method2() throws Exception {
	method3();
}

public void method3() throws Exception { ...
}
```

위의 코드처럼 기계적으로 throws Exception을 넣는것은 무엇이 문제일까? 자신이 사용하려는 메소드에 throws Exception이 선언돼있다고 상상해보자. IDE에서 에러가 표시돼어 try~catch로 예외를 처리를 하려고 해도 어떤 예외가 발생하는지 아무 정보를 얻을 수 없다. 정말 무엇인가 실행중에 뭔지는 모르겠지만 예외적인 상황이 발생할 수 있다는 것인지, 아니면 그냥 습관적으로 복붙하다 남은 throws 선언문인지 알 수가 없다. 실제로 의미있는 예외를 던지기 위해 선언됐다고 하더라도 어떤 예외인지 알기 어렵다(보통 예외이름만 봐도 예외에 대해 추측이 가능하지만 Exception만으론 정보가 부족하다).  그래서 이런 메소드를 사용하게 된다면, 동일하게 throws Exception을 선언하게 될 수 밖에 없다. 결과적으로 적절한 처리를 통해 복구될 수 있는 예외상황도 제대로 다룰 수 있는 기회를 박탈당한다.

# 2. 예외의 종류와 특징

자바에서 throw를 통해 발생시킬 수 있는 예외는 크게 세 가지가 있다.

### Error

java.lang.Error 클래스의 서브클래스들. 시스템에 비정상적인 상황이 발생했을 경우에 사용됨. 그래서 주로 자바 VM에서 발생시키는 것이고 애플리케이션 코드에서 잡으려고 하면 안된다(시스템 레벨에서 특별한 작업을 하는게 아니라면 애플리케이션에서는 에러에 대한 처리는 신경쓰지 않아도 된다).

### Exception과 체크 예외

java.lang.Exception 클래스와 그 서브클래스들은 애플리케이션 코드 작업 중 예외상황이 발생했을 경우에 사용된다.

Exception 클래스는 **체크 예외** 와 **언체크 예외** 로 구분된다. 언체크 예외는 Exception의 서브클래스인 RuntimeException을 상속받은 클래스들이고, 체크예외는 언체크예외를 제외한 Exception클래스들이다.

일반적으로 예외라고하면 체크예외를 생각해도 된다. 체크예외가 발생할 수 있는 메소드를 사용하는 경우 반드시 catch문으로 잡던지 throws를 정의하여 메소드 밖으로 던져 예외 처리를 해야한다(IDE와 컴파일러에서 강제한다). 

IOException이나 SQLException을 비롯해 예외적은 상황에서 던져질 가능성이 있는 대부분이 체크 예외로 만들어져 있다.

### RuntimeException과 언체크/런타임 예외

java.lang.RuntimeException을 상속한 예외들은 명시적인 예외처리를 강제하지 않기 때문에 언체크 예외라고 불린다. 혹은 런타임 예외라고도 한다. Error와 마찬가지로 catch문으로 잡거나 throws를 선언하지 않아도 된다(명시적으로 잡거나 throws를 선언해도 상관은 없다).

런타임예외는 주로 프로그램의 오류가 있을 때 발생하도록 의도된 것이다. NullPointerException이나 IllegalArgumentException등이 있다. 이런 예외는 개발자가 주의 깊게 조건을 체크하고 코드를 작성한다면 피할 수 있지만, 부주의하게 코드를 작성한다면 발생할 수 있는 예외다. 이러한 점에서 런타임 예외는 예상못한 상황에서 발생하는 게 아니기 때문에 굳이 catch나 throws를 사용하지 않아도 되도록 만들어져있다.

최근에 새로 등장하는 자바 표준 스펙의 API들은 예상 가능한 예외상황을 다루는 예외를 체크 예외로 만들지 않는 경향이 있기도 하다.

# 3. 예외처리 방법

## 예외 복구

예외상황을 파악하고 문제를 해결해서 정상 상태로 돌려놓는 것이다.

예를 들어 사용자가 요청한 파일을 읽으려 시도할 때 해당파일이 없거나 다른 문제로 인해 읽히지 않아서 IOException이 발생했다고 생각해보자. 이때는 사용자에게 상황을 알려주고 다른 파일을 이용하도록 안내해서 예외상황을 해결할 수 있다. 예외로 인해 기본 작업 흐름이 불가능할때 다른 작업으로 자연스럽게 유도하는 것이다. 이런 경우 예외상황은 다시 정상으로 돌아오고 예외를 복구했다고 볼 수 있다. 단, IOException에러 메시지를 사용자에게 그냥 던지는 것은 예외 복구라고 볼 수 없다. 예외가 처리됐으면 비록 기능적으로는 사용자에게 예외상황으로 비쳐도 애플리케이션에서는 정상적으로 설계된 흐름을 따라 진행돼야 한다.

다른 예시로, 네트워크가 불안한 환경에서 원격 DB서버에 접속하다가 실패해서 SQLException이 발생하는 경우에 접속 재시도를 해볼 수 있다. 네트워크로 인해 예외가 발생하면 일정 시간 대기했다가 다시 접속을 시도해보는 방법으로 복구하는 것이다(물론 정해진 횟수만큼 재시도해서 실패했다면 예외 복구는 포기해야 한다).

예외처리 코드를 강제하는 체크 예외들은 이렇게 예외를 어떤 식으로든 복구할 가능성이 있는 경우에 사용한다.

아래는 통제 불가능한 외부 요인으로 인해 예외가 발생하면 MAX_RETRY만큼 재시도를 하는 예시다. 사전에 미리 성공여부를 확인할 수 없고, 재시도가 의미 있는 경우라면 이렇게 재시도함으로써 예외를 복구할 수 있다.

```java
int maxretry = MAX_RETRY;
while(maxretry-- > 0) {
	try{
		... //예외가 발생할 가능성이 있는 코드
		return; //작업 성공
	} catch(SomeException e) {
		// 로그 출력. 정해진 시간만큼 대기
	} finally {
		// 리소스 반납. 정리작업
	}
}
throw new RetryFailedException(); //최대 재시도횟수를 넘기면 직접 예외 발생
```

## 예외처리 회피

이 방법은 예외를 자신을 호출한 쪽으로 던져버리는 것이다. throws문으로 선언하거나 catch문으로 예외를 잡은 후에 로그를 남기고 다시 예외를 던지는것이다.

```java
// 예외처리 회피 예시 1
public void add() throws SQLException {
	//JDBC API
}

// 예외처리 회피 예시 2
public void add() throws SQLException {
	try {
		//JDBC API
	} catch(SQLException e) {
		//로그 출력
		throw e;
	}
}
```

예외를 회피하는 것은 예외를 복구하는 것처럼 의도가 분명해야 한다. 콜백/템플릿처럼 긴밀한 관계에 있는 다른 오브젝트에게 예외처리 책임을 분명히 지게 하거나, 자신을 사용하는 쪽에서 예외를 다루는 게 최선의 방법이라는 분명한 확인이 있어야 한다.

## 예외 전환

예외 회피와 비슷하게 예외를 복구해서 정상적인 상태로 만들 수 없기 때문에 예외를 메소드 밖으로 던지는 것이다. 하지만 예외 회피와 달리, 발생한 예외를 적절한 예외로 전환해서 던진다.

예외 전환은 보통 두 가지 목적으로 사용한다.

**첫째는**  내부에서 발생한 예외를 의미가 분명한 예외로 바꿔주기 위함이다. API가 발생하는 기술적인 로우레벨을 상황에 적합한 의미를 가진 예외로 변경하는 것이다. 의미가 분명한 예외가 던져지면 서비스 계층 오브젝트에는 적절한 복구 작업을 시도할 수 있다.

```java
public void add(User user) throws DuplicateUserIdException, SQLException {
	try{ 
		//JDBC를 이용해 user정보를 insert하는 코드 또는 
		//그런 기능을 가진 다른 SQLException을 던지는 메소드를 호출하는 코드
	}catch(SQLException e) {
		// ErrorCode가 MySQL의 Duplicate Entry(1062)이면 예외 전환
		if(e.getErrorCode() == MysqlErrorNumbers.ER_DUP_ENTRY)
			throw DuplicateUserIdException();
		else
			throw e; //그 외의 경우는 SQLException 그대로
	}
}
```

보통  전환하는 예외에 발생한 예외를 담아서 중첩예외로 만드는 것이 좋다. 중첩 예외는 getCause() 메소드를 이용해서 처음 발생한 예외가 무엇인지 확인할 수 있다.

```java
//중첩 예외 생성 방법 1
catch(SQLException e) {
	...
	throw DuplicateUserIdException(e);
}
//중첩 예외 생성 방법 2
catch(SQLException e) {
	...
	throw DuplicateUserIdException().initCause(e);
}
```

**두번째** 목적은 예외를 처리하기 쉽고 단순하게 만들기 위해 **포장**하는 것이다. 중첩예외를 이용해 새로운 예외를 만들고 원인이 되는 예외를 내부에 담아서 던지는 방식은 같다. 하지만 의미를 명확하게 하려고 전환하는 것이 아니라, 주로 예외처리를 강제하는 체크 예외를 언체크 예외로 바꾸는 경우에 사용한다.

애플리케이션 로직상에서 예외조건이 발견되거나 예외상황이 발생할 수도 있다. 이런 것은 API가 던지는 예외가 아니라 애플리케이션 코드에서 의도적으로 던지는 예외이기 때문에 체크 예외를 사용하는 것이 적절하다. 비즈니스적인 의미가 있는 예외는 이에 대한 적절한 대응이나 복구 작업이 필요하기 때문이다.

일반적으로 체크예외를 계속 throws로 넘기는 건 무의미하다. 메소드 선언은 지저분해지고 아무 장점도 없다. 어차피 복구가 불가능한 예외라면 가능한 한 빨리 런타임 예외로 포장해 던지게 해서 다른 계층의 메소드를 작성할 때 불필요한 throws 선언이 들어가지 않도록 해줘야 한다.

대부분 서버환경에서는 애플리케이션 코드에서 처리하지 않고 전달된 예외들을 일괄적으로 다룰 수 있는 기능을 제공한다. 어차피 복구 못할 예외라면 애플리케이션 코드에서 런타임예외로 던져버리고, 예외처리 서비스 등을 이용해 로그를 남기고, 관리자에게 메일을 보내고, 사용자에게 안내 메세지를 보여주는 식으로 처리하는게 바람직하다.

# 4. 예외처리 전략

## 런타임 예외의 보편화

일반적으로 **체크예외**는 일반적인 예외를 다루고, **언체크 예외**는 시스템 장애나 프로그램상의 오류에 사용한다고 했다. 자바는 체크 예외를 조금이라도 복구할 가능성이 있는 예외적인 상황으로 보고 catch블록이나 throws선언을 강제한다. 이는 실제로는 예외를 제대로 다루고 싶지 않을 만큼 짜증나게 만드는 원이이 되기도 한다.

자바 엔터프라이즈 서버환경에서는 수많은 사용자가 동시에 요청을 보내고 각 요청이 독립적인 작업으로 취급된다. 하나의 요청을 처리하는 중에 예외가 발생하면 해당 작업만 중단시키면 그만이다. 서버의 특정 계층에서 예외가 발생했을 때 작업을 일시 중지하고 사용자와 바로 커뮤니케이션하면서 예외상황을 복구할 수 있는 방법이 없다.

차라리 애플리케이션 차원에서 예외상황을 미리 파악하고, 예외가 발생하지 않도록 차단하는 게 좋다. 또는 프로그램의 오류나 외부 환경으로 인해 예외가 발생하는 경우라면 빨리 해당 요청의 작업을 취소하고 서버 관리자나 개발자에게 통보해주는 편이 낫다.

자바의 환경이 서버로 이동하면서 체크 예외의 활용도와 가치는 점점 떨어지고 있다. 자칫하면 throws Exception이 선언된 무의미한 메소드들을 낳을 뿐이다. 그래서 대응이 불가능한 체크예외라면 빨리 런타임 예외로 전환해서 던지는 게 낫다.

요즘의 API들은 항상 복구할 수 있는 예외가 아니라면 일단 언체크 예외로 만드는 경향이 있다. 언체크 예외라도 필요하다면 catch블록으로 잡아서 복구하거나 처리할 수 있다. 하지만 대개는 복구 불가능하고 RuntimeException등으로 포장해서 던져야 할테니 아예 API 차원에서 런타임 예외를 던지도록 만드는 것이다.

## add() 메소드의 예외처리

메소드 처리중 발생하는 의미 있는 예외는 해당 메소드를 바로 호출한 오브젝트 대신 더 앞단의 오브젝트에서 다룰 수도 있다. 어디에서든 그 예외를 잡아서 처리할 수 있다면 굳이 체크 예외로 만들지 않고 런타임 예외로 만드는 게 낫다. 대신 해당 메소드에 명시적으로 해당 예외를 던진다고 선언해야한다. 그래야 메소드를 사용하는 개발자에게 의미 있는 정보를 전달해 줄 수 있다. 런타임 예외도 throws로 선언할 수 있으니 문제 될 것은 없다.

```java
//아이디 중복 시 사용하는 예외
public class DuplicateUserIdException extends RuntimeException {
	public DuplicateUserIdException(Throwable cause) {
			super(cause);// 중첩예외를 만들 수 있도록 생성자 추가
	}
}
```

```java
public void add(User user) throws DuplicateUserIdException {
	try{ 
		//JDBC를 이용해 user정보를 insert하는 코드 또는 
		//그런 기능을 가진 다른 SQLException을 던지는 메소드를 호출하는 코드
	}catch(SQLException e) {
		if(e.getErrorCode() == MysqlErrorNumbers.ER_DUP_ENTRY)
			throw DuplicateUserIdException(e);  //예외 전환
		else
			throw new RuntimeException(e); // 예외 포장
	}
}
```

런타임 예외를 일반화해서 사용하는 방법은 여러모로 장점이 많다. 단, 런타임 예외로 만들었기 때문에 사용에 더 주의를 기울일 필요도 있다. 컴파일러가 예외처리를 강제하지 않으므로 신경쓰지 않으면 예외상황을 충분히 고려하지 않을 수도 있기 때문이다. 런타임예외를 사용하는 경우 API문서나 레퍼런스 문서 등을 통해, 메소드를 사용할 때 발생할 수 있는 예외의 종류와 원인, 활용 방법을 자세히 설명해 두자.

## 애플리케이션 예외

런타임 예외 중심의 전략은 일단 복구할 수 있는 예외는 없다고 가정하고 예외가 생겨도 어차피 런타임 예외이므로 시스템 레벨에서 알아서 처리해줄 것이고, 꼭 필요한 경우는 런타임 예외라도 잡아서 복구하거나 대응해줄 수 있으니 문제될 것이 없다는 낙관적인 태도를 기반으로 한다.

반면에 시스템 또는 외부의 예외상황이 원인이 아니라 애플리케이션 자체의 로직에 의해 의도적으로 발생시키고, 반드시 catch해서 무엇인가 조치하도록 요구하는 예외도 있다. 이를 일반적으로 **애플리케이션 예외**라고 한다.

출금기능을 개발할때 메소드를 설계하는 방법은 두가지이다.

첫번째는 정상적인 출금처리를 했을 경우와 잔고 부족이 발생했을 경우에 각각 다른 종류의 리턴값을 돌려주는 것이다(각각 모두 정상리턴이다). 이 메소드를 호출한 쪽은 반드시 리턴값을 확인하여 경우에 따라 다른 작업 흐름을 가져가야 한다. 이 경우에는 예외상황에 대한 리턴 값을 명확하게 코드화하고 잘 관리하지 않으면 혼란이 생길 수 있다. 잔고가 부족한 경우 리턴되는 값을 체크할때 -1로 할지 -999로 할지 개발자마다 다를 수 있다. 그 외에도, 결과값을 확인하는 조건문이 자주 등장하면서 코드가 지저분하고 흐름을 파악하기 어려워질 수 있다.

두번째는 정상적은 흐름을 따르는 코드는 그대로 두고, 잔고 부족과 같은 예외는 비즈니스적인 의미를 띤 예외를 던지도록 하는 것이다. 이 방법에서는 예외상황을 처리하는 catch 블록을 메소드 호출 직후에 둘 필요는 없다. 예외가 발생할 수 있는 코드를 try 블록 안에 깔끔하게 정리하고 예외상황에 대한 처리는 catch블록에 모아 둘 수 있기 때문에 코드를 이해하기 편하다(try문 안에는 정상적인 흐름만 존재하기때문에 보기 편할것이다). 이때는 의도적으로 체크예외를 던진다. 그래서 개발자가 잊지 않고 잔고 부족처럼 자주 발생 가능한 예외상황에 대한 로직을 구현하도록 강제해주는게 좋다.

```java
try{
	BigDecimal balance = account.withdraw(amount);
	...
	// 정상적인 처리 결과를 출력하도록 진행
}catch(InsufficientBalanceException e) {
	// InsufficientBalanceException에 담긴 인출 가능한 잔고금액 정보를 가져옴
	BigDecimal availFunds = e.getAvailFunds();
	...
	// 잔고 부족 안내 메시지를 준비하고 이를 출력하도록 진행
}
```

# 5. 정리 및 사견

런타임예외(언체크예외)는 명시적으로 throw를 하지 않아도 예외가 던져진다. 

체크에러는 메소드에 throws를 선언하거나 try~catch로 예외를 처리해야한다.

try~catch문에서 try블록은 정상적인 처리 로직이고, catch블록은 try블록이 처리 되는 도중 예외가 발생하면 처리해야 할 로직이다. 즉, catch블록은 일반적으로 예외를 복구하거나 예외를 전환하기 위한 로직이 들어가야 한다.

그리고 catch문에서 로그를 찍은 다음 다시 throw를 하는 행위는 그저 로그만 찍을뿐이지 예외를 정상처리흐름으로 돌려놓는 것이 아니다.

예외가 발생했을때 실질적으로 catch문에서 어플리케이션에 대한 복구를 진행하는것이 쉽지 않다. 그래서 실제 서비스에서는 대부분 정상적인 작업 흐름을 종료시키고 유저에게 오류안내메세지를 내보내도록 처리하곤 한다.

그런데 체크예외는 예외처리를 강제하기때문에 예외에 대한 안내메세시를 내보내거나 관리자에게 메일을 발송하는 기능을 수행하는 부분까지 throws지옥이 발생할 것이다(스프링에서 ExceptionHandler가 정의된 contollerAdvice까지 예외를 계속 던지거나 혹은 시스템레벨에서 처리되도록 어플리케이션 전체에서 throws를 던져야 한다)

그렇기 때문에 실질적으로 뭔가 처리하지 않고 throw지옥을 만드는 체크예외를 언체크예외로 전환하여 처리하는 것이 좋을것이다. 물론, 예외가 발생한다는 것을 명시적으로 알려주기 위해 체크예외를 언체크예외로 전환하여 던지는 해당 메소드에 언체크예외를 throw한다고 정의해줘야 한다.

아래는 스프링으로 작성한 언체크예외를 처리할때 간략한 흐름을 설명하기 위한 코드다. (컨트롤러부분 생략함)

```java
// 1. 언체크익셉션을 정의했다
public class TestException extends RuntimeException{
}
```

```java
@Service
public class SubService {
    public String testFunc() throws TestException {
				// 2. 무조건 언체크예외를 throw하는 메소드를 정의했다.
        throw new TestException();
    }
}
```

```java
@Service
public class TestService {

    @Autowired
    SubService service;

    public String testFunc() {
        String test = null;
				// 2에서 정의한 메소드를 호출하는데도 예외를 처리하지 않아도 된다. 언체크예외이기 때문이다.
        test = service.testFunc();
        System.out.println("XXXXX" + test);
        return test;
    }
}

```

TestService의 testFunc()가 수행될때 언체크예외가 발생하면서, 유저에게는 http500에러 메세지가 전달되고 콘솔에는 아래와 같인 에러메세지가 남는다. 물론 testFunc의 [System.out.println("XXXXX" + test)]은 수행되지 않는다.

```java
2021-02-21 23:11:34.320 ERROR 34231 --- [nio-8080-exec-1] o.a.c.c.C.[.[.[/].[dispatcherServlet]    : Servlet.service() for servlet [dispatcherServlet] in context with path [] threw exception [Request processing failed; nested exception is com.machntek.demo.Exception.TestException] with root cause

com.machntek.demo.Exception.TestException: null
	at com.machntek.demo.service.SubService.testFunc(SubService.java:9) ~[main/:na]
	at com.machntek.demo.service.TestService.testFunc(TestService.java:16) ~[main/:na]
	at com.machntek.demo.controller.DemoController.func(DemoController.java:15) ~[main/:na]
	...생략
```

아래의 예외핸들러를 추가하면 콘솔에는 "#######테스트ㅋㅋ"라는 메세지가 출력되고, 유저에게 서버에러메세지가 전달되지 않는다. 예외가 시스템레벨까지 전달되기 전에 ExceptionHandler로 처리하는 것이다. 이 예외 핸들러에서 로그를 찍고 예외시 사용자에게 전달할 메세지를 생성하여 내보내는것이 적절할 것이다. 그러면 유저는 고객센터에 문의를 하겠지...

```java
@ControllerAdvice
public class ControllerAdviceTest {
    @ExceptionHandler(RuntimeException.class)
    public void nullPointerException(RuntimeException e) {
        System.out.println("#######테스트ㅋㅋ");
    }
}
```

정리하자면 예외를 catch문으로 잡아서 바로 예외상황을 정상로직으로 돌려놓거나, 다시 throw함으로서 예외가 전파가 되고 어디선가 예외상황을 정상로직으로 돌려놓는것은 예외 복구이다.(내가 생각했을때 기준을 잡는다면, 더이상 throw하지 않고 catch문에서 로직을 처리하여 정상처리흐름으로 만드는 부분이 있다면 복구이다.) catch문에서 예외를 던지는게 아니라 try문과는 다른 값을 return하는것도 정상흐름이라 보고있다. 예외를 throw하는 메소드를 사용하는 객체입장에선 해당 메소드에서 예외가 발생한건지 뭔지 모르기 때문이다.

그 외에 단순히 로그를 찍거나 사용자에게 오류에 대한 메세지를 보내는것 또는 계속해서 throw를 하여 시스템차원에서 처리되도록 하는것은 그냥 예외 복구가 아니다. 프로그램 코드 어디에선가 계속 Exception객체가 남아있다면 정상처리흐름이 아니다. 이것은 언체크예외로 전환하는게 깔끔하다.