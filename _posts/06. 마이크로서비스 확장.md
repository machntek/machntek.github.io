# 예외처리

## 커스텀 예외 메시지
예외를 커스텀하고 커스텀 메시지로 적절한 응답 상태를 반환하는 방법을 살펴보자. 커스텀 예외 메시지의 구조를 정의하기 위해 빈을 작성해보자.
```java
public class ExceptionResponse {
	private Date timestamp = new Date();
	private String message;
	private String details;

	public ExceptionResponse(String message, String details) {
		super();
		this.message = message;
		this.details = details;
	}

	public Date getTimestamp() {
		return timestamp;
	}

	public String getMessage() {
		return message;
	}

	public String getDetails() {
		return details;
	}
}
```

TodoNotFoundException이 발생하면 ExceptionResponse 빈을 사용해 응답을 반환할 것이다. 다음 코드는 TodoNotFoundException.class에 대한 전역 예외 처리를 만드는 방법이다.
```java
@ControllerAdvice
@RestController
public class RestResponseEntityExceptionHandler extends ResponseEntityExceptionHandler {
    @ExceptionHandler(TodoNotFoundException.class) 
    public final ResponseEntity<ExceptionResponse> todoNotFound(TodoNotFoundException ex) {
        ExceptionResponse exceptionResponse = new ExceptionResponse( ex.getMessage(), "Any details you would want to add");
        return new ResponseEntity<ExceptionResponse>(exceptionResponse, new HttpHeaders(), HttpStatus.NOT_FOUND);
    }
}
```
- RestResponseEntityExceptionHandler extends ResponseEntityExceptionHandler : ResponseEntityExceptionHandler를 상속하고 있다. 이 클래스는 중앙 집중식 예외 처리 클래스인 ControllerAdvice를 위해 스프링 MVC가 제공하는 기본 클래스다.
- @ExceptionHandler(TodoNotFoundException.class) : 메서드가 특정 예외 TodoNotFoundException.class를 처리하도록 정의한다. 커스텀 예외 처리가 정의돼 있지 않은 다른 예외는 스프링 부트가 제공하는 디폴트 예외 처리를 따른다.
- ExceptionResponse exceptionResponse = new ExceptionResponse( ex.getMessage(), "Any details you would want to add") : 커스텀 예외 응답을 작성한다.
- new ResponseEntity<ExceptionResponse>(exceptionResponse, new HttpHeaders(), HttpStatus.NOT_FOUND) : 앞에서 정의한 커스텀 예외를 가진 404 Not Found 응답을 반환하는 정의다.

존재하지 않는 todo에 대한 GET요청으로 서비스를 실행할때(http://localhost:8080/users/Jack/todos/222)는 다음과 같은 응답을 얻는다.
```
{
    "timestamp" : 141...,
    "message" : "Todo Not Found",
    "details" : "Any details you would want to add"
}
```


# HATEOS
//생략

# 벨리데이션
JST349스펙은 빈 벨리데이션 API 1.1을 정의한다. 하이버네이트 벨리데이터는 레퍼런스 구현체다. 두 가지 모두 spring-boot-web-starter 프로젝트의 의존성으로 정의된다.
- hibernate-validator-5.2.5.Final.jar
- validation-api-1.1.0.Final.jar

createTodo 서비스 메서드에 대한 간단한 벨리데이션을 작성한다. 벨리데이션을 만드는 데는 두 가지 단계가 필요하다.
1. 컨트롤러 메서드에서 벨리데이션 사용 가능
2. 빈에 벨리데이션 추가

## 컨트롤러 메서드 벨리데이션 활성화
```java
@RequestMapping(method=RequestMethod.POST, path="/users/{name}/todos")
ResponseEntity<?> add(@PathVariable String name, @Valid @RequestBody Todo todo) {}
```
@Valid(package javax.validation) 어노테이션은 벨리데이션을 위한 파라미터를 표시하기 위해 사용된다. Todo빈에 정의된 벨리데이션은 add 메서드가 실행되기 전에 실행된다.

## 빈 벨리데이션 정의
```java
public class Todo {
    private int id;

    @NotNull
    private String user;
    @Size(min=9, message="Enter at least 10 Characters.")
    private String desc;
}
```
빈을 검증하는 데 사용할 수 있는 어노테이션은 많다. 다음은 몇 가지 빈 벨리데이션 어노테이션이다.
- @AssertFalse, @AssertTrue : boolean 요소다.
- @AssertFalse : false를 확인한다.
- @Future : 어노테이션이 달린 요소는 미래의 날짜여야 한다.
- @Past : 어노테이션이 달린 요소는 과거의 날짜여야 한다.
- @Max
- @Min
- @NotNull
- @Pattern : 어노테이션된 {@code CharSequence} 요소는 지정된 정규 표현식과 일치해야 한다. 정규 표현식은 자바 정규 표현식 규칙을 따른다.
- @Size : 어노테이션 요소 크기는 지정된 범위 내에 있어야 한다.

## 단위 테스팅 벨리데이션
다음 예제는 우리가 추가한 검증을 단위 테스트 할 수 있는 방법을 보여준다.
```java
@Test
public void createTodo_withValidationError() throws Exception {
    Todo mockTodo = new Todo(CREATED_TODO_ID, "Jack", "Learn Spring MVC", new Date(), false);

    String todo = "{\"user\":\"Jack\",\"desc\":\"Learn\",\"done\":\"false\"}";

    when(service.addTodo(anyString(), anyString(), isNull(), anyBoolean())).thenReturn(mockTodo);
    MvcResult result = mvc.perform(
        MockMvcRequestBuilders.post("/users/Jack/todos").content(todo).contentType(MediaType.APPLICATION_JSON))
        .andExpect(status().is4xxClientError()).andReturn();
    )
}
```

# REST 서비스 문서화
//생략
