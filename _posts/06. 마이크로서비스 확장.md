# 예외처리

## 커스텀 예외 메시지
예외를 커스텀하고 커스텀 메시지로 적절한 응답 상태를 반환하는 방법을 살펴보자. 커스텀 예외 메시지의 구조를 정의하기 위해 빈을 작성해보자.
```java
public class ExceptionResponse {
	private Date timestamp = new Date();
	private String message;
	private String details;

	public ExceptionResponse(String message, String details) {
		super();
		this.message = message;
		this.details = details;
	}

	public Date getTimestamp() {
		return timestamp;
	}

	public String getMessage() {
		return message;
	}

	public String getDetails() {
		return details;
	}
}
```

TodoNotFoundException이 발생하면 ExceptionResponse 빈을 사용해 응답을 반환할 것이다. 다음 코드는 TodoNotFoundException.class에 대한 전역 예외 처리를 만드는 방법이다.
```java
@ControllerAdvice
@RestController
public class RestResponseEntityExceptionHandler extends ResponseEntityExceptionHandler {
    @ExceptionHandler(TodoNotFoundException.class) 
    public final ResponseEntity<ExceptionResponse> todoNotFound(TodoNotFoundException ex) {
        ExceptionResponse exceptionResponse = new ExceptionResponse( ex.getMessage(), "Any details you would want to add");
        return new ResponseEntity<ExceptionResponse>(exceptionResponse, new HttpHeaders(), HttpStatus.NOT_FOUND);
    }
}
```
- RestResponseEntityExceptionHandler extends ResponseEntityExceptionHandler : ResponseEntityExceptionHandler를 상속하고 있다. 이 클래스는 중앙 집중식 예외 처리 클래스인 ControllerAdvice를 위해 스프링 MVC가 제공하는 기본 클래스다.
- @ExceptionHandler(TodoNotFoundException.class) : 메서드가 특정 예외 TodoNotFoundException.class를 처리하도록 정의한다. 커스텀 예외 처리가 정의돼 있지 않은 다른 예외는 스프링 부트가 제공하는 디폴트 예외 처리를 따른다.
- ExceptionResponse exceptionResponse = new ExceptionResponse( ex.getMessage(), "Any details you would want to add") : 커스텀 예외 응답을 작성한다.
- new ResponseEntity<ExceptionResponse>(exceptionResponse, new HttpHeaders(), HttpStatus.NOT_FOUND) : 앞에서 정의한 커스텀 예외를 가진 404 Not Found 응답을 반환하는 정의다.

존재하지 않는 todo에 대한 GET요청으로 서비스를 실행할때(http://localhost:8080/users/Jack/todos/222)는 다음과 같은 응답을 얻는다.
```
{
    "timestamp" : 141...,
    "message" : "Todo Not Found",
    "details" : "Any details you would want to add"
}
```


# HATEOS
//생략

# 벨리데이션
JST349스펙은 빈 벨리데이션 API 1.1을 정의한다. 하이버네이트 벨리데이터는 레퍼런스 구현체다. 두 가지 모두 spring-boot-web-starter 프로젝트의 의존성으로 정의된다.
- hibernate-validator-5.2.5.Final.jar
- validation-api-1.1.0.Final.jar

createTodo 서비스 메서드에 대한 간단한 벨리데이션을 작성한다. 벨리데이션을 만드는 데는 두 가지 단계가 필요하다.
1. 컨트롤러 메서드에서 벨리데이션 사용 가능
2. 빈에 벨리데이션 추가

## 컨트롤러 메서드 벨리데이션 활성화
```java
@RequestMapping(method=RequestMethod.POST, path="/users/{name}/todos")
ResponseEntity<?> add(@PathVariable String name, @Valid @RequestBody Todo todo) {}
```
@Valid(package javax.validation) 어노테이션은 벨리데이션을 위한 파라미터를 표시하기 위해 사용된다. Todo빈에 정의된 벨리데이션은 add 메서드가 실행되기 전에 실행된다.

## 빈 벨리데이션 정의
```java
public class Todo {
    private int id;

    @NotNull
    private String user;
    @Size(min=9, message="Enter at least 10 Characters.")
    private String desc;
}
```
빈을 검증하는 데 사용할 수 있는 어노테이션은 많다. 다음은 몇 가지 빈 벨리데이션 어노테이션이다.
- @AssertFalse, @AssertTrue : boolean 요소다.
- @AssertFalse : false를 확인한다.
- @Future : 어노테이션이 달린 요소는 미래의 날짜여야 한다.
- @Past : 어노테이션이 달린 요소는 과거의 날짜여야 한다.
- @Max
- @Min
- @NotNull
- @Pattern : 어노테이션된 {@code CharSequence} 요소는 지정된 정규 표현식과 일치해야 한다. 정규 표현식은 자바 정규 표현식 규칙을 따른다.
- @Size : 어노테이션 요소 크기는 지정된 범위 내에 있어야 한다.

## 단위 테스팅 벨리데이션
다음 예제는 우리가 추가한 검증을 단위 테스트 할 수 있는 방법을 보여준다.
```java
@Test
public void createTodo_withValidationError() throws Exception {
    Todo mockTodo = new Todo(CREATED_TODO_ID, "Jack", "Learn Spring MVC", new Date(), false);

    String todo = "{\"user\":\"Jack\",\"desc\":\"Learn\",\"done\":\"false\"}";

    when(service.addTodo(anyString(), anyString(), isNull(), anyBoolean())).thenReturn(mockTodo);
    MvcResult result = mvc.perform(
        MockMvcRequestBuilders.post("/users/Jack/todos").content(todo).contentType(MediaType.APPLICATION_JSON))
        .andExpect(status().is4xxClientError()).andReturn();
    )
}
```

# REST 서비스 문서화
//생략

# 스프링 시큐리티로 REST 서비스 보호
//생략

# 국제화
//생략

# 캐싱 
서비스의 데이터 캐싱은 애플리케이션의 성능과 확장성을 향상시키는데 중요한 역할을 한다. 스프링은 어노테이션에 기반한 캐싱 추상화를 제공한다. 스프링 캐싱 어노테이션을 사용해 시작한다. 나중에 JSR-107캐싱 어노테이션을 소개하고, 이를 스프링 추상화와 비교한다.

## Spring-boot-starter-cache
스프링 부트는 spring-boot-starter-cache를 캐싱하기 위한 스타터 프로젝트를 제공한다. 이것을 애플리케이션에 추가하면 JSR-107 및 스프링 캐싱 어노테이션을 사용하는 데 필요한 모든 의존성이 생긴다.
pom.xml 파일에 추가해보자
```xml
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-cache</artifactId>
</dependency>
```

## 캐싱 활성화
캐싱을 사용하기 전에 애플리케이션에서 캐싱을 활성화 해야 한다. 
```java
@EnableCaching
@SpringBootApplication
public class Application {}
```
@EnableCaching은 스프링 부트 애플리케이션에서 캐싱을 가능하게 한다. 스프링 부트는 적절한 CacheManager 프레임워크를 자동으로 구성해 관련 캐시 공급자 역할을 한다. 스프링 부트가 CacheManager를 어떻게 결정하는지에 대한 세부 사항을 살펴보자.

## 데이터 캐싱
캐싱을 활성화했으므로 데이터를 캐시하려는 메서드에 @Cacheable어노테이션을 추가할 수 있다.
```java
@Cacheable("todos")
public List<Todo> retrieveTodos(String user) {}
```
앞의 예에서 특정 사용자가 수행할 작업이 캐시된다. 특정 사용자에 대한 메서드의 첫번째 호출 시 todos가 서비스에서 검색된다. 동일한 사용자에 대한 후속 호출 시 데이터는 캐시에서 반환된다. 스프링은 또한 조건부 캐싱을 제공한다.
```java
@Cacheable(cacheNames="todos", condition="#user.length < 10")
public List<Todo> retrieveTodos(String user) {}
```
또한 스프링은 캐시에서 데이터를 제거하고 캐시할 일부 커스텀 데이터를 추가하는 추가 어노테이션을 제공한다.

- @CachePut : 데이터를 캐시에 명시적으로 추가하는 데 사용된다
- @CacheEvict : 캐시에서 오래된 데이터를 제거하는 데 사용된다
- @Caching : 여러개의 중첩된 @Cacheable, @CachePut 및 @CacheEvict 어노테이션을 동일한 메서드에서 사용할 수 있다.

## JSR-107 캐싱 어노테이션
JSR-107의 목표는 캐싱 어노테이션을 표준화하는 것이다.
- @CacheResult : @Cacheable과 유사하다
- @CacheRemove : @CacheEvict와 유사하다. @CacheRemove는 예외가 발생하는 경우, 조건부 제거를 지원한다.
- @CacheRemoveAll : @CacheEvict와 유사(allEntries = true); 캐시에서 모든 항목을 제거하는 데 사용된다.

JSR-107과 스프링의 캐싱 어노테이션은 제공하는 기능 측면에서 상당히 유사하다. 어느 쪽이든 좋은 선택이다. 표준이기 때문에 JSR-107이 좀 더 나은 선택일 수 있다. 동일한 프로젝트에서 둘 다 사용해서는 안된다.

### 자동 감지 순서
캐싱이 활성화 되면 스프링 부트 자동 설정이 캐싱 공급자를 찾기 시작한다. 다음 목록은 스프링 부트가 캐싱 공급자를 검색하는 순서다.
- JCache(JSR-107)(EhCache 3, Hazelcast, Infinispan 등)
- EhCache 2.x
- 헤즐캐스트
- 인피니스팬
- 카우치베이스
- 레디스
- 카페인
- 구아바
- 심플
