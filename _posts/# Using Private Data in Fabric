# Using Private Data in Fabric

## Build a collection definition JSON file

컬렉션 정의는 누가 데이터를 영속시킬수 있는지, 얼마나 많은 피어에게 데이터가 전달되는지, 얼마나 오래 영속되는지 기술한다.

```
// collections_config.json
[
  {
       "name": "collectionMarbles",
       "policy": "OR('Org1MSP.member', 'Org2MSP.member')", // 컬렉션데이터 영속할 수 있도록 허용된 org 피어들.
       "requiredPeerCount": 0, //private데이터 전파하기 위해 필요한 피어 수( 체인코드의 보증 조건으로서)())
       "maxPeerCount": 3, //데이터 중복을 위해 현재 승인 피어가 데이터를 배포하려고 시도하는 다른 피어의 수입니다. 승인 피어가 다운되면 개인 데이터를 가져 오기위한 요청이있는 경우 커밋시 다른 피어를 사용할 수 있습니다.
       "blockToLive":1000000, //유지기간, 0으로 셋팅하면 무한
       "memberOnlyRead": true
  },

  {
       "name": "collectionMarblePrivateDetails",
       "policy": "OR('Org1MSP.member')",
       "requiredPeerCount": 0,
       "maxPeerCount": 3,
       "blockToLive":3,
       "memberOnlyRead": true
  }
]
```
collection definition file은 chaincode definition이 채널에 커밋될때 배포된다.(peer 라이프사이클 커맨드를 사용해서)

## Read and Write private data using chaincode APIs

데이터와 collection policy의 매핑은 chaincode api로 컨트롤된다.
컬렉션 데피니션을 사용해 프라이빗데이터 읽기쓰기는 GetPrivateData(), PutPrivateData()로 가능하다.


## Reading collection data

GetPrivateData()는 아규먼트가 2개다. (컬렉션 이름, 데이터키).

## Writing private data

PutPrivateData()로 프라이빗db에 저장함.
collection.json의 policy definition은 Org1과 Org2의 모든 피어가 그들의 프라이빗db에 프라이빗데이터를 저장하고 transact할수 있게 한다.


## Start the network
네트워크 내렸다가 다시!

test-network디렉터리에서 카우치db와 함께 test네트워크 up 해라
./network.sh up createChannel -s couchdb

LevelDB 혹은 CouchDB가 컬렉션으로 쓰일수 있다.

*** 여기서부터
## Install and define a chaincode with a collection

클라이언트app은 체인코드를 통해 블록체인원장과 작동한다.
우리가 체인코드와 상호작용하기 전에, 채널의 멤버들이 (프라이빗데이터컬렉션conf를 포함한 chaincode governance를 정의하는) 체인코드 정의에 동의해야한다.

peer lifecycle chaincode로 패키징, install, 체인코드 정의를 할거다.

체인코드는 우리의 피어에 인스톨되기 전에 패키징돼야한다. peer lifecycle chaincode package로 패키징

{peer lifecycle chaincode package -> peer lifecycle chaincode install -> peer lifecycle chaicode approveformyorg -> peer lifecycle chaincode commit}

[example]
네트워크 시작하고나서 환경변수.
```
export PATH=${PWD}/../bin:${PWD}:$PATH
export FABRIC_CFG_PATH=$PWD/../config/
export CORE_PEER_TLS_ENABLED=true
export CORE_PEER_LOCALMSPID="Org1MSP"
export CORE_PEER_TLS_ROOTCERT_FILE=${PWD}/organizations/peerOrganizations/org1.example.com/peers/peer0.org1.example.com/tls/ca.crt
export CORE_PEER_MSPCONFIGPATH=${PWD}/organizations/peerOrganizations/org1.example.com/users/Admin@org1.example.com/msp
export CORE_PEER_ADDRESS=localhost:7051
```

1. 체인코드 패키징
```
peer lifecycle chaincode package marblesp.tar.gz --path ../chaincode/marbles02_private/go/ --lang golang --label marblespv1
```

2. 우리 피어에 체인코드 설치하기
```
peer lifecycle chaincode install marblesp.tar.gz
```

성공시 메세지로 체인코드 identifier를 리턴한다.
```
2020-07-20 00:50:47.938 UTC [cli.lifecycle.chaincode] submitInstallProposal -> INFO 001 Installed remotely: response:<status:200 payload:"\nKmarblespv1:3f19c08fe56c85fb85c346330bf96a7ab9ecd8ac970d6c7c81e1c5dc84a1a895\022\nmarblespv1" > 
2020-07-20 00:50:47.938 UTC [cli.lifecycle.chaincode] submitInstallProposal -> INFO 002 Chaincode code package identifier: marblespv1:3f19c08fe56c85fb85c346330bf96a7ab9ecd8ac970d6c7c81e1c5dc84a1a895
```

3. 이제 Org2로 똑같이 한다.(체인코드 설치)
```
export CORE_PEER_LOCALMSPID="Org2MSP"
export CORE_PEER_TLS_ROOTCERT_FILE=${PWD}/organizations/peerOrganizations/org2.example.com/peers/peer0.org2.example.com/tls/ca.crt
export CORE_PEER_MSPCONFIGPATH=${PWD}/organizations/peerOrganizations/org2.example.com/users/Admin@org2.example.com/msp
export CORE_PEER_ADDRESS=localhost:9051

peer lifecycle chaincode install marblesp.tar.gz
```

## Approve the chaincode definition
체인코드 사용하고싶은 각 채널멤버는 체인코드definition을 그들의 조직에 승인해야한다.

peer lifecycle chaicode approveformyorg로 승인한다. 

체인코드definition은 marbles02_private샘플을 동반한 프라이빗데이터를 포함한다.
우리는 컬렉션json파일을 --collections-config 플래그로 제공할거다.

1. 설치된 체인코드의 패키지id를 너의 피어에 쿼리해라
```
peer lifecycle chaincode queryinstalled
```

응답으로 인스톨커맨드에서와 같은 패키지id를 받는다.

```
Installed chaincodes on peer:
Package ID: marblespv1:3f19c08fe56c85fb85c346330bf96a7ab9ecd8ac970d6c7c81e1c5dc84a1a895, Label: marblespv1
```

2. 패키지ID를 환경변수로 선언하라.
```
export CC_PACKAGE_ID=marblespv1:3f19c08fe56c85fb85c346330bf96a7ab9ecd8ac970d6c7c81e1c5dc84a1a895
```

3. 우리는 Org1의 cli를 실행중이다. 다음 환경변수 셋팅해라
```
export CORE_PEER_LOCALMSPID="Org1MSP"
export CORE_PEER_TLS_ROOTCERT_FILE=${PWD}/organizations/peerOrganizations/org1.example.com/peers/peer0.org1.example.com/tls/ca.crt
export CORE_PEER_MSPCONFIGPATH=${PWD}/organizations/peerOrganizations/org1.example.com/users/Admin@org1.example.com/msp
export CORE_PEER_ADDRESS=localhost:7051
```

4. 체인코드definition을 승인하기위해 다음을 실행하라. 다음 명령은 컬렉션definition파일의 경로를 포함한다.
```
export ORDERER_CA=${PWD}/organizations/ordererOrganizations/example.com/orderers/orderer.example.com/msp/tlscacerts/tlsca.example.com-cert.pem
peer lifecycle chaincode approveformyorg -o localhost:7050 --ordererTLSHostnameOverride orderer.example.com --channelID mychannel --name marblesp --version 1.0 --collections-config ../chaincode/marbles02_private/collections_config.json --signature-policy "OR('Org1MSP.member','Org2MSP.member')" --init-required --package-id $CC_PACKAGE_ID --sequence 1 --tls --cafile $ORDERER_CA
```

성공시 응답
```
2020-07-20 01:30:41.827 UTC [chaincodeCmd] ClientWait -> INFO 001 txid [b1845c6f22f3c9e915eebf59750484582c1c95306f0c2913ef1a9d088fda771d] committed with status (VALID) at 
```

5. 이제 Org2에서도 동일하게
```
export CORE_PEER_LOCALMSPID="Org2MSP"
export CORE_PEER_TLS_ROOTCERT_FILE=${PWD}/organizations/peerOrganizations/org2.example.com/peers/peer0.org2.example.com/tls/ca.crt
export CORE_PEER_MSPCONFIGPATH=${PWD}/organizations/peerOrganizations/org2.example.com/users/Admin@org2.example.com/msp
export CORE_PEER_ADDRESS=localhost:9051

peer lifecycle chaincode approveformyorg -o localhost:7050 --ordererTLSHostnameOverride orderer.example.com --channelID mychannel --name marblesp --version 1.0 --collections-config ../chaincode/marbles02_private/collections_config.json --signature-policy "OR('Org1MSP.member','Org2MSP.member')" --init-required --package-id $CC_PACKAGE_ID --sequence 1 --tls --cafile $ORDERER_CA
```

## Commit the chaincode definition
충분한 수의 조직이 체인코드definition을 승인하면, 한 조직은 채널에 definition을 커밋할 수 있다.
peer lifecycle chaincode commit 사용하라.
이 명령은 컬렉션definition도 채널에 deploy한다.

체인코드definition이 채널에 커밋되면 사용할 수 있다. marbles private data 체인코드에는 initiation function이 있어서, peer chaincode invoke 커맨드로 Init()펑션을 인보크 해야한다.(다른 펑션들을 쓰기 전에)

1. marbles private data 체인코드 정의를 커밋하기 위해 다음을 실행.
```
export ORDERER_CA=${PWD}/organizations/ordererOrganizations/example.com/orderers/orderer.example.com/msp/tlscacerts/tlsca.example.com-cert.pem
export ORG1_CA=${PWD}/organizations/peerOrganizations/org1.example.com/peers/peer0.org1.example.com/tls/ca.crt
export ORG2_CA=${PWD}/organizations/peerOrganizations/org2.example.com/peers/peer0.org2.example.com/tls/ca.crt

peer lifecycle chaincode commit -o localhost:7050 --ordererTLSHostnameOverride orderer.example.com --channelID mychannel --name marblesp --version 1.0 --sequence 1 --collections-config ../chaincode/marbles02_private/collections_config.json --signature-policy "OR('Org1MSP.member','Org2MSP.member')" --init-required --tls --cafile $ORDERER_CA --peerAddresses localhost:7051 --tlsRootCertFiles $ORG1_CA --peerAddresses localhost:9051 --tlsRootCertFiles $ORG2_CA
```

응답
```
2020-07-20 06:45:13.826 UTC [chaincodeCmd] ClientWait -> INFO 001 txid [6dd5d8990e139f7e21f676fd99c0175b81313f41aa19e5eeefeb74ce56227523] committed with status (VALID) at localhost:9051
2020-07-20 06:45:13.828 UTC [chaincodeCmd] ClientWait -> INFO 002 txid [6dd5d8990e139f7e21f676fd99c0175b81313f41aa19e5eeefeb74ce56227523] committed with status (VALID) at localhost:7051
```

2. Init펑션 인보크를 위해 다음을 실행
```
peer chaincode invoke -o localhost:7050 --ordererTLSHostnameOverride orderer.example.com --channelID mychannel --name marblesp --isInit --tls --cafile $ORDERER_CA --peerAddresses localhost:7051 --tlsRootCertFiles $ORG1_CA -c '{"Args":["Init"]}'
```

## Store private Data
샘플의 모든 private data를 거래할수 있는 Org1의 멤버로서, Org1의 피어로 switch하고 요청을 보내보자.

Org1으로 환경변수 셋팅
```
export CORE_PEER_LOCALMSPID="Org1MSP"
export CORE_PEER_TLS_ROOTCERT_FILE=${PWD}/organizations/peerOrganizations/org1.example.com/peers/peer0.org1.example.com/tls/ca.crt
export CORE_PEER_MSPCONFIGPATH=${PWD}/organizations/peerOrganizations/org1.example.com/users/Admin@org1.example.com/msp
export CORE_PEER_ADDRESS=localhost:7051
```

initMarble함수를 인보크해서 마블프라이빗데이터 생성해보자.
[name : marble1
owner : tom
color : blue
size : 35
price : 99]

프라이빗데이터 price는 name, owner, color, size와 따로 저장되는걸 떠올려봐라.
이때문에 initMarble 펑션은 PutPrivateData() API를 2번 호출한다.

또한, 프라이빗데이터가 --transient 플래그로 넘어온다.
transient 데이터로 전달 된 입력은 데이터를 개인용으로 유지하기 위해 트랜잭션에서 유지되지 않습니다.
transient 데이터는 바이너리데이터로 전달되기 때문에, CLI를 사용하려면 base64인코딩을 해야만한다.
환경 변수를 사용하여 base64로 인코딩 된 값을 캡처하고 tr 명령을 사용하여 Linux base64 명령이 추가하는 문제가있는 줄 바꿈 문자를 제거합니다.
```
export MARBLE=$(echo -n "{\"name\":\"marble1\",\"color\":\"blue\",\"size\":35,\"owner\":\"tom\",\"price\":99}" | base64 | tr -d \\n)
peer chaincode invoke -o localhost:7050 --ordererTLSHostnameOverride orderer.example.com --tls --cafile ${PWD}/organizations/ordererOrganizations/example.com/orderers/orderer.example.com/msp/tlscacerts/tlsca.example.com-cert.pem -C mychannel -n marblesp -c '{"Args":["initMarble"]}' --transient "{\"marble\":\"$MARBLE\"}"

```
응답
```
[chaincodeCmd] chaincodeInvokeOrQuery->INFO 001 Chaincode invoke successful. result: status:200
```

## Query the private data as an authorized peer
우리 컬렉션definition은 Org1, Org2의 멤버들이 name, color, size, owner 프라이빗데이터를 갖게 한다.
하지만 오직 Org1의 피어만 price 프라이빗데이터를 가질수 있다.

첫번째 쿼리는 아규먼트로 collectionMarbles를 전달하는 readMarble펑션을 호출한다.
두번째 쿼리는 아규먼트로 collectionMarblePrivateDetails를 전달하는 readMarblePrivateDetails펑션을 호출한다.

Org1으로 marble1의 프라이빗데이터를 쿼리하라.
쿼리는 원장에 기록되지 않으므로 marble 이름을 임시 입력으로 전달할 필요가 없습니다.

````
peer chaincode query -C mychannel -n marblesp -c '{"Args":["readMarble","marble1"]}'
```
```응답
{"color":"blue","docType":"marble","name":"marble1","owner":"tom","size":35}
```

Org1의 멤버로서 marble1의 price프라이빗 데이터 쿼리는
```
peer chaincode query -C mychannel -n marblesp -c '{"Args":["readMarblePrivateDetails","marble1"]}'
```
```응답
{"docType":"marblePrivateDetails","name":"marble1","price":99}
```

## Query the private data as an unauthorized peer

이제 Org2의 멤버로 변경해서 진행할거다.

### Switch to a peer in Org2MSP
```
export CORE_PEER_LOCALMSPID="Org2MSP"
export CORE_PEER_TLS_ROOTCERT_FILE=${PWD}/organizations/peerOrganizations/org2.example.com/peers/peer0.org2.example.com/tls/ca.crt
export CORE_PEER_MSPCONFIGPATH=${PWD}/organizations/peerOrganizations/org2.example.com/users/Admin@org2.example.com/msp
export CORE_PEER_ADDRESS=localhost:9051
```
### Query private data Org2 is authorized to
```
peer chaincode query -C mychannel -n marblesp -c '{"Args":["readMarble","marble1"]}'
```
```응답
{"docType":"marble","name":"marble1","color":"blue","size":35,"owner":"tom"}
```

### Query private data Org2 is not authorized to
Org2의 피어는 그들의 사이드DB에 price데이터를 가지지 않는다.
이 데이터를 쿼리하려고하면 공개 상태와 일치하는 키의 해시를 다시 얻지 만 비공개 상태는 갖지 않습니다.
```
peer chaincode query -C mychannel -n marblesp -c '{"Args":["readMarblePrivateDetails","marble1"]}'
```
```응답
Error: endorsement failure during query. response: status:500
message:"{\"Error\":\"Failed to get private details for marble1:
GET_STATE failed: transaction ID: d9c437d862de66755076aeebe79e7727791981606ae1cb685642c93f102b03e5:
tx creator does not have read access permission on privatedata in chaincodeName:marblesp collectionName: collectionMarblePrivateDetails\"}"
```

## Purge Private Data
off-chain 데이터베이스로 복제 될 수있을 때까지 개인 데이터가 원장에 있어야만하는 사용 사례의 경우, 
트랜잭션의 불변의 증거 역할을하는 데이터의 해시 만 남기고 특정 세트 수의 블록 후에 데이터를 제거할 수 있습니다.

거래 당사자가 채널의 다른 조직에 공개하고 싶지 않은 개인정보나 민감정보같은 프라이빗데이터가 있을수도 있다. 
따라서 수명이 제한되어 있으며 컬렉션 정의의 blockToLive 속성을 사용하여 지정된 수의 블록에 대해 블록 체인에서 기존의 변경되지 않은 후에 제거 할 수 있습니다.

우리의 collectionMarblePrivateDetails 정의는 blockToLive 속성 값이 3이라는 것을 의미합니다.
이는이 데이터가 3 개의 블록에 대해 사이드 데이터베이스에 존재 한 후 제거 될 것임을 의미합니다.
이 콜렉션 정의 collectionMarblePrivateDetails는 PutPrivateData() API를 호출하고 collectionMarblePrivateDetails를 아규먼트로 전달할 때 initMarble() 함수의 price 프라이빗 데이터와 연관됩니다.

우리는 체인에 블록을 추가하는 단계를 밟은 다음 체인에 4 개의 새로운 블록을 추가하는 4 개의 새로운 트랜잭션 (새로운 대리석 생성, 3 개의 대리석 전송)을 발행하여 가격 정보가 제거되는 것을 지켜 볼 것입니다. 네 번째 거래 (세 번째 마블 전송) 후 개인 데이터 가격이 제거되었는지 확인합니다.

Org1으로 다시 변경해보자.
```
export CORE_PEER_LOCALMSPID="Org1MSP"
export CORE_PEER_TLS_ROOTCERT_FILE=${PWD}/organizations/peerOrganizations/org1.example.com/peers/peer0.org1.example.com/tls/ca.crt
export CORE_PEER_MSPCONFIGPATH=${PWD}/organizations/peerOrganizations/org1.example.com/users/Admin@org1.example.com/msp
export CORE_PEER_ADDRESS=localhost:7051
```

새로운 터미널 윈도우를 열고 다음 명령을 실행해서 이 피어의 프라이빗데이터 로그를 봐라. 가장 높은 블록넘버를 기억하라.
```
docker logs peer0.org1.example.com 2>&1 | grep -i -a -E 'private|pvt|privdata'
```

피어 컨테이너로 돌아와, marble1 price데이터를 쿼리하라. (쿼리는 새로운 트랜잭션을 원장에 생성하지 않는다. 아무 데이터도 전송되지 않기 때문.)
```
peer chaincode query -C mychannel -n marblesp -c '{"Args":["readMarblePrivateDetails","marble1"]}'
```
```응답
{"docType":"marblePrivateDetails","name":"marble1","price":99}
```

price데이터는 여전히 프라이빗데이터원장에 있다.

새로운 marble2를 만들어보자. 이는 체인에 새로운 블럭을 생성한다.
```
export MARBLE=$(echo -n "{\"name\":\"marble2\",\"color\":\"blue\",\"size\":35,\"owner\":\"tom\",\"price\":99}" | base64 | tr -d \\n)
peer chaincode invoke -o localhost:7050 --ordererTLSHostnameOverride orderer.example.com --tls --cafile ${PWD}/organizations/ordererOrganizations/example.com/orderers/orderer.example.com/msp/tlscacerts/tlsca.example.com-cert.pem -C mychannel -n marblesp -c '{"Args":["initMarble"]}' --transient "{\"marble\":\"$MARBLE\"}"
```

다시 터미널로 와서 프라이빗데이터 로그를 봐보자. 블럭 높이가 1증가된걸 볼수있다.
```
docker logs peer0.org1.example.com 2>&1 | grep -i -a -E 'private|pvt|privdata'
```

다시 marble1의 price를 쿼리해보면 여전히 같은 데이터를 볼수 있다.
```
peer chaincode query -C mychannel -n marblesp -c '{"Args":["readMarblePrivateDetails","marble1"]}'

응답
{"docType":"marblePrivateDetails","name":"marble1","price":99}
```

marble2를 "joe"에게 전송해보자. 이 트랜잭션은 체인에 두번째 블럭을 생성한다.
```
export MARBLE_OWNER=$(echo -n "{\"name\":\"marble2\",\"owner\":\"joe\"}" | base64 | tr -d \\n)
peer chaincode invoke -o localhost:7050 --ordererTLSHostnameOverride orderer.example.com --tls --cafile ${PWD}/organizations/ordererOrganizations/example.com/orderers/orderer.example.com/msp/tlscacerts/tlsca.example.com-cert.pem -C mychannel -n marblesp -c '{"Args":["transferMarble"]}' --transient "{\"marble_owner\":\"$MARBLE_OWNER\"}"
```

다시 터미널로 와서 프라이빗데이터 로그를 봐보자. 블럭 높이가 1증가된걸 볼수있다.
```
docker logs peer0.org1.example.com 2>&1 | grep -i -a -E 'private|pvt|privdata'
```

marble2를 "tom"에게 보내보자. 이는 새로운 블록을 만든다.
```
export MARBLE_OWNER=$(echo -n "{\"name\":\"marble2\",\"owner\":\"tom\"}" | base64 | tr -d \\n)
peer chaincode invoke -o localhost:7050 --ordererTLSHostnameOverride orderer.example.com --tls --cafile ${PWD}/organizations/ordererOrganizations/example.com/orderers/orderer.example.com/msp/tlscacerts/tlsca.example.com-cert.pem -C mychannel -n marblesp -c '{"Args":["transferMarble"]}' --transient "{\"marble_owner\":\"$MARBLE_OWNER\"}"
```

마지막으로 "jerry"에게 보내자. price 프라이빗데이터가 이 트랜잭션 이후에 제거될거다.
```
export MARBLE_OWNER=$(echo -n "{\"name\":\"marble2\",\"owner\":\"jerry\"}" | base64 | tr -d \\n)
peer chaincode invoke -o localhost:7050 --ordererTLSHostnameOverride orderer.example.com --tls --cafile ${PWD}/organizations/ordererOrganizations/example.com/orderers/orderer.example.com/msp/tlscacerts/tlsca.example.com-cert.pem -C mychannel -n marblesp -c '{"Args":["transferMarble"]}' --transient "{\"marble_owner\":\"$MARBLE_OWNER\"}"
```

marble1의 price데이터를 조회해보자
```
peer chaincode query -C mychannel -n marblesp -c '{"Args":["readMarblePrivateDetails","marble1"]}'
```
```응답
Error: endorsement failure during query. response: status:500
message:"{\"Error\":\"Marble private details does not exist: marble1\"}"
```

## Using indexed with private data
인덱스는 private data 컬렉션에 적용될 수 있다. "META-INF/statedb/couchdb/collections/<collection_name>/indexes"디렉터리에 인덱스를 패키징하면 된다.
[예시]
{"index":{"fields":["docType","owner"]},"ddoc":"indexOwnerDoc", "name":"indexOwner","type":"json"}

체인코드를 프로덕션환경에 배포하기 위해, 체인코드와 함께 인덱스를 정의하기를 추천한다. (한번 체인코드가 피어에 설치되고 채널에 인스턴스화 되면, 체인코드와 지원인덱스가 유닛으로서 자동적으로 배포되도록.)
--collections-config 플래그가 컬렉션 JSON파일을 지정하도록 기술되면,  채널에서 체인 코드 인스턴스화시 관련 인덱스가 자동으로 배포됩니다.

