# 의존성 주입 이해

## 의존성 이해 
``` java
public class BusinessServiceImpl {
  public long calculateSum(User user) {
    DataServiceImpl = new DataServiceImpl();
    long sum = 0;
    for (Data data : dataService.retrieveData(user)) {
      sum += data.getValue();
    }
    return sum;
  }
```
인터페이스를 사용하면 느슨하게 결합된 코드를 만들 수 있다. 우리는 인터페이스를 구현하는 모든 와이어링을 잘 정의된 의존성으로 교체할 수 있다.

``` java
public class BusinessServiceImpl {
  private DataService dataService;
  public long calculateSum(User user) {
    long sum = 0;
    for (Data data : dataService.retrieveData(user)) {
      sum += data.getValue();
    }
    return sum;
  }
  public void setDataService(DataService dataService) {
      this.dataService = dataService;
  }
```
누가 DataServiceImpl 클래스의 인터페이스를 생성하고, BusinessServiceImpl 클래스에 연결할 것인가? 이것이 바로 스프링 IoC컨테이너가 필요한 이유다.

## 스프링 IoC컨테이너
스프링 IoC컨테이너는 애플리케이션 개발자가 생성한 설정에 따라 빈을 생성하고 연결한다.

- 질문 1 : 스프링 IoC 컨테이너는 어떤 빈을 생성해야 하는지 어떻게 알 수 있을까? 스프링 IoC컨테이너가 BusinessServicImpl 클래스와 DataServiceImpl 클래스를 위한 빈을 생성하는 방법은 무엇일까?
- 질문 2 : 스프링 IoC컨테이너는 빈을 서로 묶는 방법을 어떻게 알고 있을까? 특히, 스프링 IoC컨테이너는 DataSerivceImpl 클래스의 인스턴스를 Business ServiceImpl 클래스에 주입하는 방법을 알고 있을까?
- 질문 3 : 스프링 IoC 컨테이너는 빈을 검색하는 위치를 어떻게 알 수 있을까? 클래스 패스에 있는 모든 패키지를 검색하는 것은 비효율적이다.

### 빈과 와이어링 정의
첫번째 질문과 관련하여, 빈을 생성해야 하는 클래스에서 @Repository, @Component, @Service 어노테이션을 사용해 처리할 수 있다. @Componenet 는 스프링 빈을 정의하는 가장 일반적인 방법이다. 
@Service는 비즈니스 서비스 구성 요소에 사용된다
@Repository는 데이터 액세스 객체 구성 요소에 사용한다.
```java
@Repository
public class DataServiceImpl implements DataService
@Service
public class BusinessServiceImpl implements BusinessService
```

두번째 질문과 관련하여, BusinessServiceImpl클래스에서 DataService 인터페이스의 인스턴스 변수에 @Autowired어노테이션을 지정해야한다.
```java
public class BusinessServiceImpl {
    @Autowired
    private DataService dataService;
}
```
빈 와이어링이 정의됐다.

```java
@Repository
public class DataServiceImpl implements DataService {
    public List<Data> retireveData(User user) {
        return Arrays.asList(new Data(10), new Data(20));
    }
}
```

### 스프링 IoC 컨테이너 생성

스프링 IoC컨테이너를 생성하는 방법이 2가지 있다
- 빈팩토리
- 애플리케이션 콘텍스트

> 빈 팩토리는 스프링 IoC(빈 생명 주기 및 와이어링)의 기초다. 애플리케이션 콘텍스트는 기본적으로 엔터프라이즈 콘텍스트에서 일반적으로 필요한 추가 기능을 사용하는 빈 팩토리의 상위 집합이다. **스프링에서는 애플리케이션 콘텍스트가 소비하는 추가 몇 KB 메모리가 중요한 경우를 제외하고는 모든 시나리오에서 애플리케이션 콘텍스트를 사용할 것을 권장**한다.

애플리케이션 콘텍스트에 대해 *자바 구성* 또는 *XML 구성*을 가질 수 있다.


### 애플리케이션 콘텍스트에 대한 자바 구성
다음은 간단한 자바 콘텍스트 구성을 만드는 방법을 보여준다
```java
@Configuration
class SpringContext {
}
```
핵심은 @Configuration이다. 이는 스프링 구성으로 정의한 것이다.

마지막으로 세번째 질문 관련하여, 컴포넌트 스캔을 정의해 검색할 패키지를 스프링 IoC컨테이너에 알려줘야한다.
```java
@Configuration
@ComponentScan(basePackages = { "com.mastering.spring" })
class SpringContext {
}
```

##### 퀵 리뷰
스프링 콘텍스트를 시작하면 다음과 같은 일이 발생한다.
* com.mastering.spring 패키지를 검색해 BusinessServiceImpl 및 DataServiceImpl 빈을 찾는다.
* DataServiceImpl에는 의존성이 없다. 따라서 DataServiceImpl을 위한 빈이 생성된다
* BusinessServiceImpl에는 DataService에 대한 의존성이 있다. DataServiceImpl은 DataSerivce의 구현체다. 따라서 오토와이어드 기준과 일치한다. BusinessServiceImpl을 위한 빈이 생성되고, DataServiceImpl을 위해 생성된 빈은 setter를 통해 자동으로 채워진다.

##### 자바 구성으로 애플리케이션 콘텍스트 실행
다음 프로그램은 자바 콘택스트를 시작하는 방법이다. 애플리케이션 콘텍스트를 AnnotationConfigApplicationContext로 구동하기 위해 main 메서드를 사용한다.
```java
public class LaunchJavaContext {
    private static final User DUMMY_USER = new User("dummy");
    public static Logger logger = Logger.getLogger(LauchJavaContext.class);
    public static void main(String[] args) {
        ApplicationContext context = new AnnotationConfigApplicationContext(SpringContext.class); 
        BusinessService service = context.getBean(BusinessService.class);
        logger.debug(service.calculateSum(DUMMY_USER));
    }
}
```
다음 코드줄은 애플리케이션 콘텍스트를 만든다. 자바 구성을 기반으로 애플리케이션 콘텍스트를 만들려고 한다. 따라서 AnnotationConfigApplicationContext를 사용해야 한다.
```java
ApplicationContext context = new AnnotationConfigApplicationContext(SpringContext.class); 
```
콘텍스트가 시작되면 비즈니스 서비스 빈을 가져와야 한다. 여기서는 빈의 타입을 인수로 전달하는 getBean메서드를 사용한다.
```java
BusinessService service = context.getBean(BusinessService.class);
```
LaunchJavaContext 프로그램을 실행해 애플리케이션 콘텍스트를 시작하도록 설정됐다.

### 애플리케이션 콘텍스트 XML 구성

앞의 예에서 스프링 자바 구성을 사용해 애플리케이션 콘텍스트를 시작했다. 스프링은 XML 구성을 지원한다.
다음 예제는 XML 구성을 사용해 애플리케이션 콘텍스트를 시작하는 방법을 보여준다. 이에는 두 가지 단계가 있다.
* XML 스프링 구성 정의하기
* XML 구성으로 애플리케이션 콘텍스트 실행하기

##### XML 스프링 구성 정의
다음 구성 파일은 BusinessApplicationContext.xml이라는 이름으로 src/main/resources 디렉터리에 작성된다.
``` xml
<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<beans> <!- 네임스페이스정의 삭제됨 -->
    <context:component-scan base-package="com.mastering.spring"/>
</benas>
```
구성요서 검사는 context:component-scan을 사용해 정의된다.

##### XML구성으로 애플리케이션 콘텍스트 실행
다음은 XML구성으로 애플리케이션 콘텍스트 시작하는 방법이다. ClassPathXmlApplicationContext를 갖고 애플리케이션 콘텍스트를 구동하기 위해 main메서드를 사용한다.
```java
public class LaunchXmlContext {
    private static final User DUMMY_USER = new User("dummy");
    public static Logger logger = Logger.getLogger(LauchJavaContext.class);
    public static void main(String[] args) {
        ApplicationContext context = new ClassPathXmlApplicationContext("BusinessApplicationContext.xml"); 
        BusinessService service = context.getBean(BusinessService.class);
        logger.debug(service.calculateSum(DUMMY_USER));
    }
}
```
다음 라인은 애플리케이션 콘텍스트를 만든다. XML구성을 기반으로 애플리케이션 콘텍스트를 만들려고 한다. 따라서 AnnotationConfigApplicationContext를 생성하기 위해 ClassPathApplicationContext를 사용한다.
```java
ApplicationContext context = new ClassPathXmlApplicationContext(SpringContext.class);
```

### 스프링 콘텍스트를 사용해 JUnit 작성
이전 절에서는 main메서드에서 스프링 콘텍스트를 시작하는 방법을 살펴봤다. 이제 단위 테스트에서 스프링 콘텍스트를 시작하는 방법을 살펴보자. SpringJUnit4ClassRunner.class 를 러너로 사용하면 스프링 콘텍스트를 시작할 수 있다.
```java
@RunWith(SpringJUnit4ClassRunner.class)
```
앞에서 작성한 XML구성을 사용해 콘텍스트 구성의 위치를 제공한다.
```java
@ContextConfiguration(locations = {"/BusinessApplicationContext.mxl"})
```

@Autowired 어노테이션을 사용하면 콘텍스트에서 테스트로 빈을 오토와이어할 수 있다. BusinessService는 다음 타입에 의해 오토와이어된다.
```java
@Autowired
private BusinessService service;
```

BusinessServiceImpl은 현재 와이어드된 DataServiceImpl이 반환한 합계를 계산하여 30을 반환한다. assertEquals를 사용해 테스트 메서드에서 30을 선언한다.
```java
long sum = service.calculateSum(DUMMY_USER);
assertEquals(30, sum);
```

단위 테스트에는 다음과 같은 여러 장점이 있다
* 미래의 결함에 대비한 안전망
* 결함이 일찍 발견된다
* TDD가 더 나은 디자인을 만든다
* 잘 작성된 테스트는 코드 및 기능의 문서화 역할을 한다.(특히, BDD Given-When-Then 스타일을 사용해 작성된 테스트)

첫번째 테스트는 실제로 단위 테스트가 아니다. 이 테스트에서 모든 빈을 로드한다. 모킹을 사용해 작성된 다음절의 테스트가 실제 단위 테스트다.

테스트의 전체 목록이다.
```java
@RunWith(SpringJUnit4ClassRunner.class)
@ContextConfiguration(locations={"BusinessApplicationContext.xml" })
public class BusinessServiceJavaContextTest {
    private static final User DUMMY_USER = new User("dummy");
    @Autowired
    private BusinessService service;

    @Test
    public void testCalculateSum() {
        long sum = service.calculateSum(DUMMY_USER);
        assertEquals(30, sum);
    }
}
```
JUnit의 문제는 진정한 단위 테스트가 아니라는 것이다. 이 테스트는 JUnit테스트를 위해 DataServiceImpl의 실제(거의) 구현을 사용한다. 
어떻게 DataService의 실제 구현을 사용하지 않고 BusinessServiceImpl을 테스트할까? 이에는 두가지 옵션이 있다.
* src/test/java 폴더에 더미 데이터를 제공하는 데이터 서비스의 stub 구현체를 만든다. 별도의 Test Context 구성을 사용해 실제 DataServiceImpl 클래스 대신, 스텁 구현을 오토와이어한다.
* DataService 모크를 만들고, 모크를 BusinessServiceImpl에 오토와이어 한다.

스텁 구현을 만든다는 것은 추가 클래스와 추가 콘텍스트를 만드는 것을 의미한다. 단위 테스트를 할 때는 데이터의 변형이 필요하기 때문에 스텁을 유지 관리하기가 더 어려워진다. 따라서 모크 사용의 두번째 옵션을 살펴본다. 모킹 프레임워크(특히, Mockito)가 발전함에 따라 단위 테스트를 실행하기 위해 스프링 콘텍스트를 시작할 필요조차 없다는 것을 알 수 있다.


## 모크 단위 테스팅
모킹은 실제 객체의 동작을 시뮬레이션하는 객체를 만드는 것이다. 이전 예제의 단위 테스트에서는 DataService의 동작을 시뮬레이션하려고 한다. stub과 달리, 런타임 시에 모크가 동적으로 생성될 수 있다.

Mockito로 모크를 만드는 데에는 여러 가지 방법이 있는데, 여기서는 그 중 가장 간단한 어노테이션을 사용한다. @Mock 어노테이션을 사용하면 DataService용 모크를 만들 수 있다

모크를 생성하고 나면 테스트 중인 클래스 BusinessServiceImpl에 이 객체를 주입해야 한다. 여기서는 @InjectMocks 어노테이션을 사용한다.

테스트 방법에서는 우리가 원하는 데이터를 제공하기 위해 모크 서비스를 stub해야한다. 모키토가 제공하는 BDD 스타일 메서드를 사용해 retrieveData 메서드를 모킹한다.

```java
@RunWith(MockitoJUnitRunner.class)
public class BusinessServiceMockitoTest {
    private static final User DUMMY_USER = new User("dummy");
    
    @Mock
    private DataService dataService;

    @InjectMocks
    private BusinessService service = new BusinessServiceImpl();

    @Test
    public void testCalculateSum() {
        BDDMockito.given(dataService.retrieveData(Matchers.any(User.class)))
        .willReturn(Arrays.asList(new Data(10), new Data(15), new Data(25))); // *stub 정의*

        long sum = service.calculateSum(DUMMY_USER);
        assertEquals(10 + 15 + 25, sum);
    }
}
```
앞의 코드에서 정의한 것이 stub이다. retireveData 메서드가 User타입의 객체와 함께 dataService모크에 호출되면, 값이 지정된 세 항목의 목록이 반환된다.

Mockito 어노테이션을 사용할 때는 특정 JUnit러너(MockitoJUnitRunncer)를 사용해야 한다. MockitoJUnitRunner는 테스트 코드를 깨끗하게 유지하는데 도움이 되며, 테스트가 실패할 경우 명확한 디버깅 정보를 제공한다. MockitoJUnitRunner는 @Mock 어노테이션으로 어노테이션된 빈을 초기화하고 각 테스트 메서드를 실행한 후, 프레임워크 사용을 검증한다.

## 컨테이너 관리 빈
이전 예제에서 자체 의존성을 만드는 클래스 대신, 스프링 IoC컨테이너가 빈과 그 의존성을 관리하는 책임을 어떻게 인계하는지 살펴봤다. 컨테이너에 의해 관리되는 빈을 '컨테이너 관리 빈'이라고 한다.

빈에 대한 생성 및 관리를 컨테이너에 위임하는 이점의 일부는 다음과 같다
* 클래스는 의존성 생성에 대한 책임이 없기 때문에 느슨하게 결합돼 테스트할 수 있다. 이는 좋은 설계와 더 적은 결점으로 나타난다.
* 컨테이너가 빈을 관리하기 때문에 빈 주위에 몇개의 기능을 더 일반적인 방법으로 도입할 수 있다. 로깅, 캐싱, 트랜잭션 관리 및 예외 처리와 같은 횡단 관심을 AOP를 사용해 빈을 중심으로 구성할 수 있다. 이는 유지관리가 쉬운 코드로 이어진다.

## 의존성 주입 타입
의존성 주입에는 자주 사용되는 두 가지 타입이 있다
* setter 주입
* 생성자 주입

### setter 주입
setter메서드를 통해 의존성을 주입하는 데 사용된다.
```java
public class BusinessServiceImpl {
    private DataService dataService;
    @Autowired
    public void setDataService(DataService dataService) {
        this.dataService = dataService;
    }
}
```
사실 setter주입을 사용하기 위해서는 setter메서드를 선언할 필요조차 없다. 변수에 @Autowired를 지정하면 스프링은 자동으로 setter주입을 사용한다. DataService의 setter주입에 필요한 코드는 다음과 같다
```java
public class BusinessServiceImpl {
    @Autowired
    private DataService dataService;
}
```

### 생성자 주입
다음 코드는 생성자를 사용하여 주입하는 예시이다
```java
public class BusinessServiceImpl {
    private DataService dataService;
    @Autowired
    public BusinessServiceImpl(DataService dataService) {
        super();
        this.dataService = dataService;
    }
}
```
앞의 코드를 실행하면, 생성자를 사용해 오토와이어링이 수행됐다는 것이 로그에 표시된다.

### 생성자 대 setter 주입
원래 XML-기반 애플리케이션 콘텍스트에서는 필수 의존성이 있는 생성자 주입과 비강제적 의존성을 가진 setter주입을 사용했다. 그러나 중요한 점은 필드 또는 메서드에서 @Autowired를 사용하면, 기본적으로 의존성이 필요하다는 것이다. @Autowired 필드에 사용할 수 있는 후보가 없으면, 오토와이어링이 실패하고 예외가 발생한다. 따라서 자바애플리케이션 콘텍스트에서는 선택 사항이 더 이상 명확하지 않다. setter 주입을 사용하면 생성 중에 객체 상태가 변경된다. 불변 객체에는 생성자 주입이 필요하다. setter주입을 사용하면 클래스에 많은 의존성이 있다는 사실을 숨길 수 있다. 생성자 주입을 사용하면 생성자의 크기가 증가하므로 이를 명확히 알 수 있다.

## 스프링 빈 스코프
스프링 빈은 여러 스코프로 만들 수 있다. 기본 스코프는 Singleton이다. 싱글톤 빈의 인스턴스는 하나뿐이기 때문에 요청과 관련된 데이터를 포함할 수 없다. 스코프는 모든 스프링 빈에서 @Scope 어노테이션과 함께 제공될 수 있다
```java
@Service
@Scope("singleton")
public class BusinessServiceImpl implements BusinessService
```
다음은 다양한 타입의 스코프다

|스코프|사용|
|---|---|
|싱글톤|기본적으로 모든 빈의 스코프는 싱글톤이다. 스프링 IoC컨테이너 인스턴스당 오직 하나의 빈 인스턴스만 사용된다. 빈에 대한 여러 참조가 있더라도 컨테이너당 한 번만 작성된다. 싱글톤 인스턴스는 캐싱돼 이 빈을 사용하는 모든 후속 요청에 사용된다. 스프링 싱글톤 스코프가 하나의 스프링 컨테이너당 하나의 객체라는 것을 지정하는 것이 중요하다. 단일 JVM에 스프링 컨테이너가 여래 개 있는 경우, 동일한 빈의 인스턴스가 여러 개 있을 수 있다. 따라서 스프링 싱글톤의 스코프는 일반적인 정의와 조금 다르다.|
|프로토타입|스프링 컨테이너에서 빈이 요청될 때마다 새로운 인스턴스가 생성된다. 빈에 상태가 포함돼 있는 경우, 프로토타입(Prototype)스코프를 사용하는 것이 좋다.|
|리퀘스트|스프링 웹 콘텍스트에서만 사용할 수 있다. 모든 HTTP요청마다 빈의 새 인스턴스가 작성된다. 빈은 요청 처리가 완료되는 즉시 폐기된다. 단일 요청과 관련된 데이터를 보유하고 있는 빈에 이상적이다.|
|세션|스프링 웹 콘텍스트에서만 사용할 수 있다. 모든 HTTP세션마다 새로운 인스턴스가 생성된다. 웹 애플리케이션의 사용자 권한과 같이 단일 사용자 고유의 데이터에 적합하다.|
|애플리케이션|스프링 엡 콘텍스트에서만 사용할 수 있다. 웹 애플리케이션당 하나의 빈 인스턴스로 특정 환경의 애플리케이션 구성에 적합하다.|

## 자바 대 XML 구성
스프링은 자바와 XML기반 구성을 똑같이 잘 지원한다. 따라서 프로그래머와 그 팀이 선택해야 한다. 어느 쪽을 선택하든 팀과 프로젝트 간에 일관성을 유지하는 것이 중요하다. 선택시 고려사항은 다음과 같다.
* 어노테이션은 빈을 더 짧고 간단하게 정의할 수 있다.
* 어노테이션은 XML기반 구성보다 적용할 수 있는 코드에 더 가깝다
* 어노테이션을 사용하는 클래스는 더 이상 간단한 POJO가 아니다. 프레임워크별 어노테이션을 사용하기 때문이다.
* 어노테이션을 사용하면 오토와이어링 문제를 해결하기 어려울 수 있다. 와이어링이 더 이상 중앙집중화 되지 않고, 명시적으로 선언되지도 않기 때문이다.
* 애플리케이션 패키지(WAR 또는 EAR) 외부에 스프링 콘텍스트 XML을 사용하면 와이어링이 좀 더 유연하다는 이점이 있다. 이렇게 하면 통합 테스트에 대해 다른 설정도 할 수 있다.

### @Autowired 어노테이션
@Autowired를 의존성에 사용하면, 애플리케이션 콘텍스트는 일치하는 의존성을 검색한다. 기본적으로 오토와이어드되는 모든 의존성이 필요하다. 가능한 결과는 다음과 같다.
- 일치하는 항목이 1개 있다 : 찾고 있는 의존 항목
- 일치하는 항목이 2개 이상 발견됐다 : 오토와이어링 실패
- 일치하는 항목이 없다 : 오토와이어링 실패

둘 이상의 후보가 발견되면 두가지 방법으로 해결 가능하다.
- 후보 중 하나만 사용하려면 @Primary 어노테이션을 사용하라
- 오토와이어링을 더욱 강화하려면 @Qualifier를 사용하라

#### @Primary 어노테이션
특정 의존성을 오토와이어할 수 있는 후보가 둘 이상 있을 때 @Primary 어노테이션을 사용한 빈이 호출된다. 다음 예제에서 QuickSort는 @Primary 어노테이션 때문에 SortingAlgorithm에 대한 의존성을 연결하는 데 사용된다.
```java
interface SortingAlgorithm {
}

@Component
class MergeSort implements SortingAlgorithm{
}

@Component
@Primary
class QuickSort implements SortingAlogrithm{
}
```
#### @Qualifier 어노테이션
@Qualifier 어노테이션은 스프링 빈에 대한 참조를 주기 위해 사용되고, 이 참조는 오토와이어드할 필요가 있는 의존성을 한정하는 데 사용된다.
다음 예에서 SomeService 서비스에서 @Qualifier("mergesort")가 사용됐기 때문에 mergesort 한정자(qualifier)를 가진 MergeSort는 오토와이어링을 위해 선택된 후보 의존성이 된다
```java
@Component
@Qualifier("mergesort")
class MergeSort implements SortingAlogrithm{
}
@Component
class QuickSort implements SortingAlogrithm{
}
@Component
class SomeService{
    @Autowired
    @Qualifier("mergesort")
    SortingAlogrithm algorithm;
}
```

## 기타 중요한 스프링 어노테이션
스프링은 빈을 정의하고 빈의 생명 주기를 관리하는데 많은 유연성을 제공한다.
|어노테이션|사용|
|---|---|
|@ScopedProxy|요청이나 세션 스코프의 빈을 싱글톤 스코프의 빈에 주입해야 하는 경우가 있다. @ScopedProxy 어노테이션은 이러한 상황에서 단일 스코프 빈에 주입되는 스마트 프록시를 제공한다.|
|@Component, @Service, @Controller, @Repository|@Component는 스프링 빈을 정의하는 가장 일반적인 방법이다. 다른 어노테이션은 이와 관련된 특정 콘텍스트를 갖고있다. * @Service는 비즈니스 서비스 레이어에서 사용된다. * @Repository는 데이터 액세스 객체에서 사용된다. * @Controller는 프레젠테이션 구성 요소에 사용된다.|
|@PostConstruct|모든 스프링 빈에서 @PostConstruct 어노테이션을 사용해 post construct 메서드를 제공한다. 이 메서드는 빈이 의존성으로 완전히 초기화 된 후에 호출된다. 빈 생명 주기 동안 한 번만 호출된다.|
|@PreDestroy|스프링 빈에서 @PreDestroy 어노테이션을 사용해 predestory 메서드를 제공한다. 이 메서드는 빈이 컨테이너에서 제거되기 전에 호출된다. 이는 빈에 의해 보유된 자원을 해제하는 데 사용된다.|

## 콘테스트 및 의존성 주입 탐색
CDI는 의존성 주입을 자바 EE로 가져오는 자바 EE의 시도다. CDI의 목표는 의존성 주입 수행방법의 기본을 표준화 하는 것이다.
스프링은 JSR-330에 정의된 표준 어노테이션을 지원한다. 대부분의 경우, 이러한 어노테이션은 스프링 어노테이션과 동일한 방식으로 처리된다.
CDI를 사용하기 전에 CDI jar에 대한 의존성을 확인해야 한다. 코드는 다음과 같다.
```xml
<dependency>
    <groupId>javax.inject</gorupId>
    <artifactId>javax.inject</artifactId>
    <version>1</version>
</dependency>
```
다음 표는 CDI 어노테이션과 스프링 프레임워크에서 제공하는 어노테이션을 비교한 것이다.
@Value, @Required 및 @Lazy 스프링 어노테이션에는 동등한 CDI 어노테이션이 없다는 점에 유의해야한다.

|CDI 어노테이션|스프링 어노테이션과 비교|
|---|---|
|@Inject|@Autowired와 비슷함. 한가지 중요한 차이점은 @Inject에 필요한 속성이 없다는 것이다.|
|@Named|@Named는 @Component와 유사하게 명명된 구성 요소를 식별한다. 게다가 @Named는 @Qualifier 스프링 어노테이션과 비슷한 이름으로 빈을 한정하는데 사용된다. 이는 하나의 의존성에 대한 오토와이어링에 대해 여러 후보가 사용 가능한 상황에 유용하다.|
|@Singleton|스프링 어노테이션 @Scope("singleton")과 유사하다.|
|@Qualifier|스프링 어노테이션의 @Qualifier와 유사하다.|

### CDI의 예
CDI는 다른 클래스의 어노테이션이 어떻게 생겼는지를 나타낸다. 스프링 애플리케이션 콘텍스트를 생성하고 시작하는 방법에는 변화가 없다.
CDI는 @Repository, @Controller, @Service 및 @Component 간에 차이를 표시하지 않는다. 앞의 모든 어노테이션 대신 @Named를 사용한다.
이 예에서는 DataServiceImpl 및 BusinessServiceImpl에 @Named를 사용한다. @Inject를 사용해 dataService를 BusinessServiceImple에 주입한다.(@Autowired대신)

```java
@Named //@Repository대신
public class DataServiceImpl implements DataService

@Named //@Service 대신
public class BusinessServiceImpl{
    @Inject //@Autowired 대신
    private DataService dataService;
}
```
