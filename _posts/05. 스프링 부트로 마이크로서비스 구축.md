# 스프링 부트는 무엇인가?
- 스프링 부트는 애플리케이션 서버도, 웹 서버도 아니다. 다양한 애플리케이션 및 웹서버와의 통합을 제공한다.
- 스프링 부트는 특정 프레임워크나 스펙을 구현하지 않는다.

## 마이크로서비스로 빠르게 프로토타입 구축
애플리케이션을 설정하는 단계는 다음과 같다.
1. 사용할 스프링 MVC, JPA, 하이버네이트의 버전을 결정하라
2. 모든 다른 레이어를 연결하는 스프링 콘텍스트를 설정하라.
3. 스프링 MVC(스프링 MVC 구성 포함)로 웹 레이어를 설정하라 (DispatcherServlet, 핸들러, 리졸버, 뷰 리졸버 등에 대한 빈 구성)
4. 데이터 레이어에서 하이버네이트를 설정하라 (SessionFactory, 데이터 소스 등에 대한 빈 구성)
5. 서로 다른 환경에 따라 애플리케이션 구성을 저장하는 방법을 결정하고 구현하라.
6. 단위 테스트를 어떻게 할 것인지 결정하라
7. 트랜잭션 전략을 결정하고 구현하라
8. 보안을 구현하는 방법을 결정하고 구현하라
9. 로깅 프레임워크를 설정하라
10. 프로덕션 환경에서 애플리케이션을 모니터링할 방법을 결정하고 구현하라.
11. 애플리케이션에 대한 통계를 제공하기 위해 메트릭스 관리 시스템을 결정하고 구현하라.
12. 애플리케이션을 웹 또는 애플리케이션 서버에 배포하는 방법을 결정하고 구현하라.

위의 단계 중 최소한 몇 가지를 완료해야 비즈니스 로직을 구축할 수 있다. 마이크로서비스는 빠른 시작을 원한다. 앞의 12단계를 모두 거치면 마이크로서비스를 쉽게 개발할 수 없다. 이것이 스프링 부트가 해결하고자 하는 문제다.

> 스프링부트를 사용하면 '바로 실행'할 수 있는 스탠드얼론, 프로덕션급 스프링 기반 애플리케이션을 쉽게 만들 수 있다. 우리는 스프링 플랫폼 및 서드파티 라이브러리에 대해 의견을 개진해 최소한의 관심으로 시작할 수 있다. 대부분의 스프링 부트 애플리케이션은 스프링 구성이 거의 필요하지 않다.

스프링부트는 개발자가 마이크로서비스 뒤에 있는 비즈니스 로직에 집중할 수 있게 해준다.

## 기본 목표
- 스프링-기반 프로젝트를 신속하게 구축
- 일반적인 사용법에 따라 기본적인 가정을 만든다. 기본값과의 차이를 처리하는 구성 옵션을 제공한다.
- 다양한 비기능적인 특징을 제공한다.
- 코드 생성을 사용하지 말고, 많은 XML 구성을 피하라

## 비기능적인 특징
- 다양한 프레임워크, 서버 및 스펙의 버전 관리 및 설정에 대한 기본 처리
- 애플리케이션 보안을 위한 기본 옵션
- 확장 가능성이 있는 기본 애플리케이션 매트릭스
- 상태 확인을 사용한 기본 애플리케이션 모니터링
- 외부화된 설정을 위한 여러 옵션

# 스프링 부트 Hello World
메이븐 사용하여 의존성 관리한다. 스프링부트 애플리케이션으로 시작하는 과정은 다음과 같다.
1. pom.xml 파일에서 spring-boot-starter-parent를 설정하라
2. 필요한 스타터 프로젝트로 pom.xml 파일을 구성하라
3. 애플리케이션을 실행하려면 spring-boot-maven-plugin을 설정하라
4. 첫 번째 스프링 부트 실행 클래스를 만들어라.

## spring-boot-starter-parent 구성
spring-boot-starter-parent를 가진 간단한 pom.xml 구성하자.
```xml
<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
	xsi:schemaLocation="http://maven.apache.org/POM/4.0.0
     http://maven.apache.org/xsd/maven-4.0.0.xsd">
	<modelVersion>4.0.0</modelVersion>
	<groupId>com.mastering.spring</groupId>
	<artifactId>springboot-example-ch5</artifactId>
	<version>0.0.1-SNAPSHOT</version>
	<name>First Spring Boot Example</name>
	<packaging>war</packaging>
	<parent>
		<groupId>org.springframework.boot</groupId>
		<artifactId>spring-boot-starter-parent</artifactId>
		<version>2.0.0.M1</version>
	</parent>
	<properties>
		<java.version>1.8</java.version>
	</properties>
	<repositories>
		<repository>
			<id>spring-milestones</id>
			<name>Spring Milestones</name>
			<url>https://repo.spring.io/milestone</url>
			<snapshots>
				<enabled>false</enabled>
			</snapshots>
		</repository>
	</repositories>
    <pluginRepositories>
		<pluginRepository>
			<id>spring-milestones</id>
			<name>Spring Milestones</name>
			<url>https://repo.spring.io/milestone</url>
			<snapshots>
				<enabled>false</enabled>
			</snapshots>
		</pluginRepository>
	</pluginRepositories>
</project>
```
왜 우리는 spring-boot-starter-parent가 필요할까?
spring-boot-starter-parent 의존성은 사용할 자바 기본버전, 스프링 부트가 사용하는 의존성의 기본 버전 및 메이븐 플러그인의 기본 설정을 포함한다.
> spring-boot-starter-parent 의존성은 스프링 부트-기반 애플리케이션에 대한 의존성 및 플러그인 관리를 제공하는 부모 POM이다.

## spring-boot-starter-parent
spring-boot-starter-parent 의존성은 POM의 상단에 정의된 spring-boot-dependencies를 상속받는다. 다음 코드 단락은 spring-boot-starter-parent에서 추출한 내용이다.
```xml
	<parent>
		<groupId>org.springframework.boot</groupId>
		<artifactId>spring-boot-dependencies</artifactId>
		<version>2.0.0.M1</version>
        <relativePath>../../spring-boot-dependencies</relativePath>
	</parent>
```
spring-boot-dependencies는 스프링 부트가 사용하는 모든 의존성에 대한 기본 의존성 관리를 제공한다. 다음은 spring-boot-dependencies에서 설정되는 다양한 의존성의 서로 다른 버전을 보여준다.
```xml
<activemq.version>5.15.3</activemq.version>
<antlr2.version>2.7.7</antlr2.version>
<appengine-sdk.version>1.9.62</appengine-sdk.version>
<artemis.version>2.4.0</artemis.version>
<aspectj.version>1.8.13</aspectj.version>
<assertj.version>3.9.1</assertj.version>
<atomikos.version>4.0.6</atomikos.version>
<bitronix.version>2.1.4</bitronix.version>
...생략
```
의존성의 특정 버전을 덮어 쓰려면 애플리케이션의 pom.xml 파일에 적절한 이름을 가진 등록 정보를 제공해야 한다.
```xml
<properties>
    <mockito.version>1.10.20</mockito.version>
</properties>
```

스프링의 특정 버전과 호환되는 최신 스프링 세션 버전은 어떻게 찾을까? 일반적인 대답은 문서를 읽는 것이다. 그러나 스프링 부트를 사용하면 spring-boot-starter-parent로 쉽게 만들 수 있다. 새로운 스프링 버전으로 업그레이드하고 싶다면 스프링 버전에 대한 spring-boot-starter-parent 의존성을 찾아야 한다. spring-boot-starter-parent의 해당 특정 버전을 사용하기 위해 애플리케이션을 업그레이드하면 다른 모든 의존성이 새 스프링 버전과 호환되는 버전으로 업그레이드된다.

## 필요한 스타터 프로젝트를 사용해 pom.xml 구성

### 스타터 프로젝트 이해
스타터는 여러가지 목적으로 커스텀이 단순화된 의존성 디스크립터다. 예를 들어, spring-boot-starter-web은 스프링 MVC를 사용해 RESTful이 포함된 웹 애플리케이션을 작성하기 위한 스타터다. 기본 임베디드 컨테이너로 톰캣을 사용한다.
spring-boot-starter-web을 의존성에 포함시키면 다음과 같이 자동으로 사전 구성된다.

- 스프링MVC
- 호환 가능한 버전의 jackson-databind(바인드용) 및 hibernate-validator(폼 벨리데이션용)
- spring-boot-starter-tomcat(톰캣을 위한 스타터 프로젝트)

spring-boot-starter-web을 사용하면 많은 프레임워크가 자동으로 설정된다. 우리는 만들고자 하는 웹 앱을 위해 단위 테스트되고, 톰캣에 배포되길 원한다. 다음 단락은 우리가 필요로하는 다양한 스타터 의존성을 보여준다. 다음 파일을 pom.xml에 추가해야 한다.

```xml
	<dependencies>
		<dependency>
			<groupId>org.springframework.boot</groupId>
			<artifactId>spring-boot-starter-web</artifactId>
		</dependency>
		<dependency>
			<groupId>org.springframework.boot</groupId>
			<artifactId>spring-boot-starter-test</artifactId>
			<scope>test</scope>
		</dependency>
		<dependency>
			<groupId>org.springframework.boot</groupId>
			<artifactId>spring-boot-starter-tomcat</artifactId>
			<scope>provided</scope>
		</dependency>
	</dependencies>
```
세 가지 스타터 프로젝트를 추가한다.
- 이미 spring-boot-starter-web에 대해 논의했다. 스프링 MVC로 웹 애플리케이션을 구현하는 데 필요한 프레임워크를 제공한다.
- spring-boot-starter-test 의존성은 단위 테스트에 필요한, 다음과 같은 테스트 프레임워크를 제공한다.
  -- JUnit : 기본 단위 테스트 프레임워크
  -- Mockito : 모킹을 위해
  -- Hamcrest, AssertJ : 검증(assert)를 위해
  -- 스프링 테스트 : 스프링 콘텍스트-기반 애플리케이션을 위한 단위 테스트 프레임워크
- spring-boot-starter-tomcat 의존성은 웹 애플리케이션을 실행하는데 있어 기본값이다. 설정을 명확하게 하기 위해 포함시킨다. spring-boot-starter-tomcat은 톰캣을 임베디드 서블릿 컨테이너로 사용하기 위한 스타터다.

이제 pom.xml을 스타터 페어런트와 필요한 스타터 프로젝트로 구성했다. spring-boot-maven-plugin을 추가하면 스프링 부트 애플리케이션을 실행할 수 있다.

## spring-boot-maven-plugin 구성
스프링 부트를 사용해 애플리케이션을 구축할 때는 다음과 같은 두 가지 상황이 발생할 수 있다.
- jar 또는 war를 빌드하지 않고 애플리케이션을 실행하고 싶다.
- 나중에 배포할 수 있도록 jar 및 war을 빌드하고자 한다.

spring-boot-maven-plugin의존성은 앞의 두 가지 상황 모두에 대한 기능을 제공한다. 다음 단락은 애플리케이션에서 spring-boot-maven-plugin을 설정하는 방법을 보여준다.
```xml
	<build>
		<plugins>
			<plugin>
				<groupId>org.springframework.boot</groupId>
				<artifactId>spring-boot-maven-plugin</artifactId>
			</plugin>
		</plugins>
	</build>
```
spring-boot-maven-plugin의존성은 스프링 부트 애플리케이션을 위한 몇가지 goal을 제공한다. 가장 인기 있는 goal은 run이다(프로젝트의 루트 폴더에서 명령 프롬프트상에 mvn spring-boot:run을 통해 실행할 수 있다).

## 첫 스프링 부트 구동 클래스 생성
다음 클래스는 간단한 스프링 부트 구동 클래스를 생성하는 방법을 설명한다. 다음 코드 단락에서처럼 SpringApplication 클래스의 정적 구동 메서드를 사용한다.
```java
package com.mastering.spring.springboot;
import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.context.ApplicationContext;

@SpringBootApplication
public class Application {
	public static void main(String[] args) {
		ApplicationContext ctx = SpringApplication.run(Application.class, args);
	}
}
```
앞의 코드는 SpringApplication클래스에서 정적 구동 메서드를 실행하는 간단한 자바 메인 메서드다.

### SpringApplication 클래스
SpringApplication 클래스는 자바 메인 메서드에서 스프링 애플리케이션을 구동하고 부트스트랩을 사용할 수 있다. 다음은 스프링 부트 애플리케이션이 부트스트랩될 때 일반적으로 수행되는 단계다.
1. 스프링의 ApplicationContext 인스턴스를 생성한다.
2. 명령줄 인수를 받아들이고, 이를 스프링 속성으로 노출하는 기능을 활성화한다.
3. 설정에 따라 모든 스프링 빈을 로드한다.

### @SpringBootApplication 어노테이션
@SpringBootApplication은 세 가지 어노테이션에 대한 바로가기다.
- @Configuration : 스프링 애플리케이션 콘텍스트 구성 파일이라는 것을 나타낸다.
- @EnableAutoConfiguration : 스프링 부트의 중요한 기능인 자동 설정을 가능하게 한다. 자동 설정은 별도의 절에서 설명한다.
- @ComponentScan : 이 클래스의 패키지와 모든 서브패키지에서 스프링 빈을 검색할 수 있도록 해준다.

## Hello World 애플리케이션 구동
Hello World 애플리케이션은 여러 가지 방법으로 실행할 수 있다. 자바 애플리케이션으로 실행하는 가장 간단한 옵션으로 실행해보자. IDE에서 애플리케이션 클래스를 마우스 오른쪽 버튼으로 클릭하고 자바 애플리케이션을 실행한다.

간단한 pom.xml파일과 하나의 자바 클래스를 사용하면 앞서 설명한 모든 기능이 포함된 스프링 MVC 애플리케이션을 시작할 수 있다. 스프링 부트에서 가장 중요한 것은 백그라운드에서 일어나는 일을 이해하는 것이다. 시작 로그를 이해하는 것이 먼저다. 메이븐 의존성을 좀 더 자세히 살펴보자.
스프링 부트는 많은 마법을 만든다. 애플리케이션을 설정하고 구동한 후에 디버깅할 때는 문제를 더 깊게 이해하는 것이 좋다.

## 자동 설정
자동 설정을 더 잘 이해할 수 있도록 애플리케이션 클래스를 확장해 몇 줄의 코드를 추가해보자
```java
    ApplicationContext ctx = SpringApplication.run(Application.class, args);
		String[] beanNames = ctx.getBeanDefinitionNames();
		Arrays.sort(beanNames);
		for (String beanName : beanNames) {
			System.out.println(beanName);
		}
```
Application.java가 자바 프로그램으로 구동되면, 빈 목록이 나타난다.

고려해야 할 사항은 다음과 같다.
- 빈들은 어디에 정의돼 있는가?
- 빈들은 어떻게 만들어지는가?

다음은 스프링 자동 설정의 마술이다.
스프링 부트 자동 설정은 스프링 부트 프로젝트에 새로운 의존성을 추가할 때마다 의존성을 기반으로 빈을 자동으로 설정하려고 시도한다.

예를 들어, spring-boot-starter-web에 의존성을 추가하면, 다음 빈이 자동으로 설정된다.
- basicErrorController, handlerExceptionResolver : 기본 예외 처리다. 예외가 발생할 때 기본 에러 페이지를 표시한다.
- beanNameHandlerMapping : 핸들러(컨트롤러)에 대한 경로를 확인하는 데 사용하면 된다.
- characterEncodingFilter : 기본 문자 인코딩 UTF-8을 제공한다.
- dispatcherServlet : 스프링 MVC 애플리케이션의 프론트 컨트롤러다.
- jacksonObjectMapper : 객체를 JSON으로 변환하고, REST 서비스에서는 JSON을 객체로 변환한다.
- messageConverters : 객체를 XML 또는 JSON으로 또는 그 반대로 변환하는 기본 메시지 컨버터다.
- multipartResolver : 웹 애플리케이션의 파일 업로드 지원을 제공한다.
- mvcValidator : HTTP 요청의 검증을 지원한다.
- viewResolver : 논리적 뷰 이름을 물리적 뷰로 해석한다.
- propertySourcesPlaceholderConfigurer : 애플리케이션 구성의 외부화를 지원한다.
- requestContextFilter : 요청에 대한 필터를 기본값으로 지정한다.
- restTemplateBuilder : REST 서비스를 호출하는 데 사용한다.
- tomcatEmbeddedServletContainerFactory : 톰캣은 스프링 부트-기반 웹 애플리케이션을 위한 기본 임베디드 서블릿 컨테이너다.

다음 절에서는 몇 가지 스타터 프로젝트와 이들이 제공하는 자동 설정을 살펴보자.

## 스타터 프로젝트
|스타터|설명|
|---|---|
|spring-boot-starter-web-services|XML기반 웹 서비스를 개발하는 스타터 프로젝트다.|
|spring-boot-starter-web|스프링MVC기반 웹 애플리케이션 또는 RESTful 애플리케이션을 구현하는 스타터 프로젝트. 기본 임베디드 서블릿 컨테이너로 톰캣이 사용된다.|
|spring-boot-starter-activemq|액티브MQ에서 JMS를 사용해 메시지-기반 통신을 지원한다|
|spring-boot-starter-integration|엔터프라이즈 인티그레이션 패턴 구현을 제공하는 스프링 인티그레이션 프레임워크를 지원|
|spring-boot-starter-test|JUnit, 모키토 및 Hamcrest matchers와 같은 다양한 단위테스트 프레임워크 지원|
|spring-boot-starter-jdbc|스프링 JDBC 지원. 기본으로 톰캣 JDBC 연결 풀을 구성한다.|
|spring-boot-starter-validation|자바 빈 밸리데이션API를 지원. 기본 구현은 hibernate-validator다.|
|spring-boot-starter-hateoas|HATEOAS를 사용하는 RESTful 서비스는 데이터뿐 아니라 현재 콘텍스트와 관련된 추가 리소스에 대한 링크를 반환한다.|
|spring-boot-starter-jersey|JAX-RS는 restapi를 개발하는 자바EE표준이다. Jersey는 기본 구현체다. 이 스타터 프로젝트는 JAX-RS-based REST API를 빌드하기 위한 기능을 제공한다.|
|spring-boot-starter-websocket|HTTP는 무상태다. 웹 소켓을 사용하면 서버와 브라우저 사이의 연결을 유지할 수 있다. 이 스타터 프로젝트는 스프링 웹 소켓을 지원한다.|
|spring-boot-starter-aop|관점지향 프로그래밍과 고급 관점지향 프로그래밍을 위한 AspectJ에 대한 지원을 제공한다|
|spring-boot-starter-amqp|기본으로제공하는 래빗MQ를 사용해 메시지를 AMQP로 전달한다.|
|spring-boot-starter-security|스프링 시큐리티를 위한 자동 설정을 가능하게 한다.|
|spring-boot-starter-data-jpa|스프링데이터JPA를 지원한다. 기본 구현체는 하이버네이트다.|
|spring-boot-starter|스프링 부트 애플리케이션의 기본 스타터 프로그램이다. 자동 설정 및 로깅을 지원한다.|
|spring-boot-starter-batch|스프링 배치를 사용해 배치 애플리케이션을 개발할 수 있는 기능을 제공한다|
|spring-boot-starter-cache|스프링 프레임워크를 사용한 캐싱에 대한 기본적인 지원이다.|
|spring-boot-starter-data-rest|스프링 데이터 REST를 사용해 REST 서비스 노출을 지원한다.|

지금까지 기본 웹 애플리케이션을 설정하고 스프링 부트와 관련된 몇가지 중요한 개념을 이해했다
- 자동설정
- 스타터 프로젝트
- spring-boot-maven-plugin
- spring-boot-starter-parent
- 어노테이션 @SpringBootApplication

# REST는 무엇인가?
용어 정리
- 자원 : 모든 정보는 자원이 될 수 있다(사람, 이미지, 비디오 또는 제품 등)
- 리프레젠테이션 : 자원을 표현하는 구체적인 방법을 말한다. 예를 들어, JSON, XML또는 HTML을 사용해 제품 리소스를 나타낼수 있다. 다른 클라이언트가 자원의 다른 표현을 요청할 수도 있다.
  
REST 제약 조건 중 일부는 다음과 같다
- 클라이언트-서버
- 무상태 : 각 서비스는 무상태여야 한다. 후속 요청은 일시적으로 저장되는 이전 요청의 일부 데이터에 의존하면 안된다. 메시지는 자기 설명적이어야 한다.
- 통일된 인터페이스 : 각 리소스에는 리소스 식별자가 있다. 웹 서비스의 경우, 이 URI예제인 /users/Jack/todos/1을 사용한다. 여기서 URI Jack은 사용자 이름, 1은 검색하고자 하는 todo의 ID다
- 캐시 가능 : 서비스 응답은 캐시가 가능해야 한다. 각 응답은 캐시 가능 여부를 표시해야 한다.
- 레이어 시스템 : 서비스 소비자를 서비스 공급자와 직접 연결하면 안된다. 요청을 캐시할 수 있기 때문에 클라이언트가 중간 레이어에서 캐시된 응답을 가져올 수 있다
- 리프레젠테이션을 통한 자원 조작 : 자원은 여러 리프레젠테이션을 가질 수 있다. 이러한 리프레젠테이션을 사용해 메시지로 자원을 수정할 수 있어야 한다.
- HATEOAS : Restful애플리케이션의 소비자는 단 하나의 고정 서비스 URL만을 알아야 한다. 또 모든 후속 자원은 자원 표현에 포함된 링크에서 발견할 수 있어야 한다.

# 첫 REST 서비스
다음 코드 단락과 같이 멤버 필드 message와 인수가 하나인 생성자를 가진 간단한 POJO WelcomeBean클래스를 생성한다.
```java
package com.mastering.spring.springboot.bean;
       public class WelcomeBean {
         private String message;
       public WelcomeBean(String message) {
         super();
         this.message = message;
       }
       public String getMessage() {
         return message;
} }
```
## 문자열을 반환하는 간단한 메서드
```
@RestController
public class BasicController {
	@GetMapping("/welcome")
	public String welcome() {
		return "Hello world";
	}
}
```
- @RestContoller : @ResponseBody와 @Controller 어노테이션의 조합 제공. 이것은 일반적으로 REST 컨트롤러를 만드는데 사용된다.
- @GetMapping("welcome") : @RequestMapping(method=RequestMethod.GET) 의 바로가기.

### 단위 테스팅
이전 컨트롤러 메서드를 테스트하기 위한 단위 테스트를 작성해보자
```java
@RunWith(SpringRunner.class)
@WebMvcTest(BasicController.class)
public class BasicControllerTest {
    @Autowired
    private MockMvc mvc;
    @Test
    public void welcome() throws Exception {
    System.out.println("test다 ");
    	mvc.perform(MockMvcRequestBuilders.get("/welcome").accept(MediaType.APPLICATION_JSON))
		    .andExpect(status().isOk()).andExpect(content().string(equalTo("Hello World")));	    
        }
}
```
이전 단위 테스트에서 BasicContoller를 사용해 모크 MVC 인스턴스를 시작한다.

- @RunWith(SpringRunner.class) : SpringRunner는 SpringJUnit4ClassRunner 어노테이션의 바로가기다. 이것은 단위테스트를 위한 간단한 스프링 콘텍스트를 시작한다.
- @WebMvcTest(BasicController.class) : SpringRunner와 함께 이 어노테이션을 사용하면 스프링 MVC 컨트롤러에 대한 간단한 테스트를 작성할 수 있다. Spring-MVC-related 어노테이션을 가진 빈만을 로드할 것이다. 이 예제에서는 테스트 중인 클래스가 BasciController인 웹 MVC 테스트 콘텍스트를 구동한다.
- @Autowired private MockMvc mvc : 요청을 하는 데 사용할 수 있는 MockMvc빈을 오토와이어한다.
  
### 통합 테스팅
통합 테스팅을 수행할 때 구성된 모든 컨트롤러와 빈을 사용해 임베디드 서버를 시작하고자 한다.
```java
@RunWith(SpringRunner.class)
@SpringBootTest(classes= Application.class, webEnvironment = SpringBootTest.WebEnvironment.RANDOM_PORT)
public class BasicControllerIT {
	private static final String LOCAL_HOST = "http://localhost:";
	
	@LocalServerPort
	private int port;
	private TestRestTemplate template = new TestRestTemplate();
	
	@Test
	public void welcome() throws Exception {
		ResponseEntity<String> response = template.getForEntity(createURL("/welcome"), String.class);
		assertThat(response.getBody(), equalTo("Hello World"));
	}

	private String createURL(String uri) {
		return LOCAL_HOST + port + uri;
	}
}
```
- @SpringBootTest(classes= Application.class, webEnvironment = SpringBootTest.WebEnvironment.RANDOM_PORT) : 스프링 TestContext 위에 추가 기능을 제공한다. 컨테이너 및 TestRestTemplate(요청 실행)을 완전히 실행하기 위한 포트 설정 지원을 제공한다.
- @LocalServerPort private int port : SpringBootTest는 컨테이너가 실행중인 포트가 포트 변수에 오토와이어드 되도록 한다.
- private String createURL(String uri) : URI에 로컬 호스트 URL과 포트를 추가해 전체 URL을 만드는 메소드다.
- private TestRestTemplate template = new TestRestTemplate() : TestRestTemplate은 일반적으로 통합테스트에 사용된다. RestTemplate 위에 추가 기능을 제공하는데,이는 통합 테스트 콘텍스트에서 특히 유용하다. 응답 위치를 검증할 수 있도록 리다이렉션을 따르지 않는다.
- template.getForEntity(createURL("/welcome"), String.class) : 주어진 URI에 대한 get 요청을 실행한다.
- assertThat(response.getBody(), equalTo("Hello World")) : 응답 본문 내용이 "Hello World"라고 가정한다.
  
## 객체를 반환하는 간단한 REST 메서드
이번에는 적절한 JSON 응답을 반환하는 메서드를 만들어보자
```java
	@GetMapping("/welcome-with-object")
	public WelcomeBean welcomeWithObject() {
		return new WelcomeBean("Hello World");
	}
```

### 요청 실행
응답해야 할 질문은 다음과 같다. 반환된 WelcomeBean 객체가 어떻게 JSON으로 변환될까? 다시 한번 말하지만, 스프링 부트 자동 설정의 마법이다. Jackson이 애플리케이션의 클래스패스에 있다면 JSON(및 그 반대) 컨버터에 대한 기본 객체의 인스턴스는 스프링 부트에 의해 자동 설정된다.

### 단위 테스팅
BasicControllerTest에 테스트 추가
```java
@Test
public void welcomeWithObject() throws Exception{
    mvc.perform(MockMvcRequestBuilders.get("/welcome-with-object").accept(MediaType.APPLICATION_JSON))
   	.andExpect(status().isOk()).andExpect(content().string(containsString("Hello World")));
}
```
이 테스트는 containString을 사용해 내용에 "Hello World"가 포함됐는제 확인하는 것을 제외하고는 초기 단위테스트와 매우 비슷하다. 여기서는 적절한 JSON테스트를 작성하는 법을 배운다.

### 통합 테스팅
BasicControllerIT에 테스트 추가
```java
    @Test
	public void welcomeWithObject() throws Exception {
		ResponseEntity<String> response = template.getForEntity(createURL("/welcome-with-object"), String.class);
		assertThat(response.getBody(), containsString("Hello World"));
	}
```

## 경로 변수를 가진 GET 메서드
경로 변수는 uri의 값을 컨트롤러 메서드 변수에 바인드하는 데 사용된다.
```java
private static final String helloWorldTemplate = "Hello World, %s!";
@GetMapping("/welcome-with-parameter/name/{name}")
public WelcomeBean welcomeWithParameter(@PathVariable String name) {
	retunr new WelcomeBean(String.format(helloWorldTemplate, name));
}
```
- @GetMapping("/welcome-with-parameter/name/{name}") : {name}은 이 값이 변수라는 것을 나타낸다. URI에 여러 개의 변수 템플릿을 가질 수 있다.
- welcomeWithParameter(@PathVariable String name) : @PathVariable은 URI의 변숫값이 변수 이름에 바인딩되도록 한다.

### 단위 테스팅
URI의 일부로 name을 전달하고, 응답에 name이 포함돼있는지 확인한다.
```java
@Test
public void welcomeWithParameter() throws Exception {
	mvc.perform(MockMvcRequestBuilders.get("/welcome-with-parameter/name/Buddy").accept(MediaType.APPLICATION_JOSN))
	.andExpect(status().isOk()).andExpect(content().string(containsString("Hello World, Buddy")));
}
```

## 통합 테스팅
```java
@Test
public void welcomeWithParameter() throws Exception {
	ResponseEntity<String> response = template.getForEntity(createURL("/welcome-with-parameter/name/Buddy"), String.class);
	assertThat(response.getBody(), containsString("Hello World, Buddy"));
}
```
우리가 구현한 단위테스트와 통합 테스트는 간단한 서브스트링 비교 대신 JSON 비교를 사용하는 것이 좋다. 다음 절에서는 REST 서비스 테스트에 초점을 맞출 것이다.

# todo 리소스 생성
다음과 같은 서비스를 만들고자 한다
- 주어진 사용자에 대한 todos목록 검색하기
- 특정 todo에 대한 세부 정보 가져오기
- 사용자를 위한 todo목록 만들기

## 메서드, 오퍼레이션, URI 요청
REST 서비스의 모범사례중 하나는 우리가 수행하는 작업을 기반으로 적절한 HTTP 요청 방법을 사용하는 것이다.
|HTTP 요청 메서드|오퍼레이션|
|---|---|
|GET|읽기-리소스에 대한 세부 정보 검색|
|POST|생성-새로운 아이템 또는 리소스 생성|
|PUT|업데이트/교체|
|PATCH|업데이트/리소스 일부 수정|
|DELETE|삭제|

- 주어진 사용자의 todos 목록 검색하기 : 이것은 READ이므로 GET 사용. URI의 정적인 것들(사용자, todo 등)에는 복수형을 사용하는 것이 좋다. /users/{name}/todos
- 특정 todo에 대한 세부 정보 검색 : GET 사용. /users/{name}/todos/{id}
- 사용자를 위한 todo 목록 만들기 : POST 사용. /users/{name}/todos

## 빈들과 서비스들
todo의 세부 정보를 검색하고 저장하려면 Todo빈과 세부 정보를 검색하고 저장하는 서비스가 필요하다.
```java
public class Todo{
	private int id;
	private String user;
	private String desc;
	private Date targetDate;
	private boolean isDone;

	public Todo() {
	}
	public Todo(int id, String user, String desc, Date targetDate, boolean isDone) {
		super();
		this.id = id;
		this.user = user;
		this.desc = desc;
		this.targetDate = targetDate;
		this.isDone = isDone;
	}
	//모든 Getters
}
```
이제 TodoService를 추가해보자
```java
@Service
public class TodoService{
	private static List<Todo> todos = new ArrayList<Todo>();
	private static int todoCount = 3;

	static {
		todos.add(new Todo(1, "Jack", "Learn Spring MVC", new Date(), false));
		todos.add(new Todo(2, "Jack", "Learn Struts", new Date(), false));
		todos.add(new Todo(3, "Jill", "Learn Hibernate", new Date(), false));
	}

	public List<Todo> retrieveTodos(String user) {
		List<Todo> filteredTodos = new ArrayList<Todo>();
		for (Todo todo:todos) {
			if(todo.getUser().equals(user)) filteredTodos.add(todo);
		}
		return filteredTodos;
	}

	public Todo addTodo(String name, String desc, Date targetDate, boolean isDone {
		Todo todo = new Todo(++todoCount, name, desc, targetDate, isDone);
		todos.add(todo);
		return todo;
	}

	public Todo retireveTodo(int id) {
		for(Todo todo:todos {
			if(todo.getId() == id) return todo;
		})
		return null;
	}
}
```
- todos의 배열 목록을 메모리에 유지 관리하며, 이 목록은 정적 이니셜라이저를 사용해 초기화된다.

## Todo 리스트 검색
```java
@RestController
public class TodoController {
	@Autowired
	private TodoService todoService;
	@GetMapping("/users/{name}/todos")
	public List<Todo> retrieveTodos(@PathVariable String name) {
		return todoService.retrieveTodos(name);
	}
}
```

### 단위 테스팅
```java
@RunWith(SpringRunner.class)
@WebMvcTest(TodoController.class)
public class TodoControllerTest{
	@Autowired
	private MockMvc mvc;
	@MockBean
	private TodoService service;
	@Test
	public void retireveTodos() throws Exception {
		List<Todo> mockList = Arrays.asList(new Todo(1, "Jack", "Learn Spring MVC", new Date(), false), new Todo(2, "Jack", "Learn Struts", new Date(), false));

		when(service.retireveTodos(anyString())).thenReturn(mockList);
		MvcResult result = mvc.perform(MockMvcRequestBuilders.get("/users/Jack/todos").accept(MediaType.APPLICATION_JSON))
		.andExpect(status().isOk()).andReturn();

		String expected = "[" + "{id:1,user:Jack,desc:\"Learn Spring MVC\",done:false}" + ","
		+ "{id:2,user:Jack,desc:\"Learn Struts\",done:false}" + "]" ;

		JSONAssert.assertEquals(expected, result.getResponse().getContentAsString(), false);
	}
}
```
- 단위 테스트를 작성하고 있다. 따라서 TodoController클래스에 있는 로직만 테스트 하려고 한다. @WebMvcTest(TodoController.class)를 사용해 TodoController 클래스만으로 모크 MVC 프레임워크를 초기화한다.
- @MockBean private TodoService service : @MockBean 어노테이션을 사용해 TodoService를 모킹하고 있다. SpringRunner로 실행되는 테스트 클래스에서 @MockBean으로 정의된 빈은 모키토 프레임워크를 사용해 만든 모킹으로 대체된다.
- when(service.retrieveTodos(anyString())).thenReturn(mockList) : 모크 목록을 반환하기 위해 retireveTodos 서비스 메서드를 모킹하고 있다.
- MvcResult result = .. : 요청에 대한 결과를 MvcResult 변수에 받아들이고 응답에 대한 검증을 수행할 수 있게 한다.
- JSONAssert.assertEquals(expected, result.getResponse().getContentAsString(), false) : JSONAssert는 JSON에 대한 검증을 수행하는 데 유용한 프레임워크다. 응답 텍스트를 예상값과 비교한다. JSONAssert는 지정되지 않은 값을 무시한다. 또 다른 장점은 검증이 실패했을 경우에 나타나는 명확한 실패 메시지다. 마지막 파라미터인 false는 비엄격(non-strict) 모드의 사용을 나타낸다. 만약 true로 변경되면 예상 결과가 정확하게 결과와 일치해야 한다.

### 통합 테스팅
정의된 모든 컨트롤러와 빈을 갖고 전체 스프링 콘텍스트를 시작한다.
```java
@RunWith(SpringJUnit4ClassRunner.class)
@SpringBootTest(classes = Application.class, webEnvironment=SpringBootTest.WebEnvironment.RANDOM_PORT)
public class TodoControllerIt {
	@LocalServerPort
	private int port;
	
	private TestRestTemplate template = new TestRestTemplate();

	@Test
	public void retrieveTodos() throws Exception {
		String expected = "[" + "{id:1,user:Jack,desc:\"Learn Spring MVC\",done:false}" + ","
		+ "{id:2,user:Jack,desc:\"Learn Struts\",done:false}" + "]" ;

		String uri = "/users/Jack/todos";
		ResponseEntity<String> response = template.getForEntity(createUrl(uri), String.class);

		JSONAssert.assertEquals(expected, response.getBody(), false);
	}
	private String createUrl(String uri) {
		return "http://localhost:" + port + uri;
	}
}
```
이 테스트는 JSONAssert를 사용해 응답을 선언하는 것을 제외하고는 BasicController의 통합 테스트와 매우 비슷하다.

## 특정 Todo의 세부 정보 검색
```java
@GetMapping(path="/users/{name}/todos/{id}")
public Todo retrieveTodo(@PathVariable String name, @PathVariable int id) {
	return todoService.retireveTodo(id);
}
```

### 단위 테스팅
```java
@Test
public void retireveTodo() throws Exception {
	Todo mockTodo = new Todo(1, "Jack", "Learn Spring MVC", new Date(), false);

	when(service.retrieveTodo(anyInt())).thenReturn(mockTodo);

	MvcResult result = mvc.perform(MockMvcRequestBuilders.get("/users/Jack/todos/1").accept(MediaType.APPLICATION_JSON))
	.andExpect(status().isOk()).andReturn();

	String expected = "{id:1,user:Jack,desc:\"Learn Spring MVC\",done:false}";

	JSONAssert.assertEquals(expectd, result.getResponse().getContentAsString(), false);
}
```
- when(service.retrieveTodo(anyInt())).thenReturn(mockTodo) : 모크Todo를 반환하기 위해 retireveTod 서비스 메서드를 모킹하고 있다.

### 통합 테스팅
```java
@Test
public void retireveTodo() throws Exception {
	String expected = "{id:1,user:Jack,desc:\"Learn Spring MVC\",done:false}";
	ResponseEntity<String> response = template.getForEntity(createUrl("/users/Jack/todos/1"), String.class);
	JSONAssert.assertEquals(expected, response.getBody(), false);
}
```

## Todo 추가
Post메서드. /users/{name}/todos
```java
	@PostMapping("/users/{name}/todos")
	ResponseEntity<?> add(@PathVariable String name, @RequestBody Todo todo) {
		Todo createdTodo = todoService.addTodo(name, todo.getDesc(), todo.getTargetDate(), todo.isDone());
		if (createdTodo == null) {
			return ResponseEntity.noContent().build();
		}
		URI location = ServletUriComponentsBuilder.fromCurrentRequest().path("/{id}")
				.buildAndExpand(createdTodo.getId()).toUri();
		return ResponseEntity.created(location).build();
	}
```
- ResponseEntity<?> add(@PathVariable String name, @RequestBody Todo todo) : HTTP POST요청은 URI를 생성된 리소스로 반환해야 한다. 이를 위해 ResourceEntity를 사용한다. @RequestBody는 요청 본문을 직접 빈에 바인드한다.
- ResponseEntity.noContent().build() : 리소스 생성 실패를 반환하는 데 사용된다.
- ServletUriComponentBuilder.fromCurrentRequest().path("/{id}").buildAndExpand(createdTodo.getId()).toUri() : 응답에서 반환된 리소스의 URI를 형식화한다.
- ResponseEntity.created(location).build() : 작성된 리소스에 대한 링크가 있는 상태 201(CREATED)을 반환한다.

### 포스트맨
응답 결과
```
Status : 201 Created
Location : http://localhost:8080/users/Jack/todos/5
```

### 단위 테스팅
```java
private static final int CREATED_TODO_ID = 4;

@Test
public void createTodo() throws Exception {
	Todo mockTodo = new Todo(CREATED_TODO_ID, "Jack", "Learn Spring MVC", new Date(), false);
	String todo = "{\"user\":\"Jack\",\"desc\":\"Learn Spring MVC\",\"done\":\"false\"}";

	when(service.addTodo(anyString(), anyString(), isNull(), anyBoolean()))
	.thenReturn(mockTodo);

	mvc.perform(MockMvcRequestBuilders.post("/users/Jack/todos").content(todo).contentType(MediaType.APPLICATION_JSON))
	.andExpect(status().isCreated()).andExpect(header().string("location", containsString("/users/Jack/todos/" + CREATED_TODO_ID)));
}
```
- andExpect(status().isCreated()).andExpect(header().string("location", containsString("/users/Jack/todos/" + CREATED_TODO_ID))) : 헤더에 생성된 리소스의 URI가 포함된 location이 있는지 확인한다.

### 통합 테스팅
```java
@Test
public void addTodo() throws Exception {
	Todo todo = new Todo(-1, "Jill", "Learn Hibernate", new Date(), false);
	URI location = template.postForLocation("/users/Jill/todos", todo);
	assertThat(location.getPath(), containsString("/users/Jill/todos/4"));
}
```
- URI location = template.postForLocation("/users/Jill/todos", todo) : 새로운 리소스를 만드는 테스트에 특히 유용한 유틸리티 메서드다. 지정한 URI에 todo를 게시하고 헤더에서 location을 가져온다.


# 자동 설정 확인
자동 설정은 스프링 부트의 가장 중요한 기능 중 하나다. 이 절에서는 스프링 부트 자동 설정이 어떻게 작동하는지 이해하기 위해 백그라운드를 간단히 살펴볼 것이다. 스프링 부트 자동 설정 마법의 대부분은 spring-boot-autoconfigure-{version}.jar에서 유래한다. 스프링 부트 애플리케이션을 시작할 때 다수의 빈이 자동으로 설정된다. spring-boot-autoconfigure-{version}.jar의 spring.factories에 있는 자동 설정 클래스 목록은 스프링 부트 애플리케이션이 실행될 때마다 구동된다. spring.factories의 하나를 간단히 살펴보자
```
org.springframework.boot.autoconfigure.web.servlet.WebMvcAutoConfiguration
```
다음은 WebMvcAutoConfiguration의 작은 코드 단락이다.
```java
@Configuration
@ConditionalOnWebApplication(type = Type.SERVLET)
@ConditionalOnClass({ Servlet.class, DispatcherServlet.class, WebMvcConfigurer.class })
@ConditionalOnMissingBean(WebMvcConfigurationSupport.class)
@AutoConfigureOrder(Ordered.HIGHEST_PRECEDENCE + 10)
@AutoConfigureAfter({ DispatcherServletAutoConfiguration.class,
		ValidationAutoConfiguration.class })
public class WebMvcAutoConfiguration {
```
- @ConditionalOnClass({ Servlet.class, DispatcherServlet.class, WebMvcConfigurer.class }) : 언급된 클래스 중 하나라도 클래스 패스에 있으면 자동 설정이 사용된다. 웹 스타터 프로젝트를 추가할 때 언급된 모든 클래스의 의존성을 가져온다. 따라서 자동 설정이 활성화된다.
- @ConditionalOnMissingBean(WebMvcConfigurationSupport.class) : 이 자동설정은 애플리케이션이 WebMvcConfigurationSupport.class 클래스의 빈을 명시적으로 선언하지 않은 경우에만 활성화된다.
- @AutoConfigureOrder(Ordered.HIGHEST_PRECEDENCE + 10) : 특정 자동 설정의 우선순위를 지정한다.

같은 클래스의 메서드 중 하나의 코드를 살펴보자
```java
        @Bean
		@ConditionalOnBean(ViewResolver.class)
		@ConditionalOnMissingBean(name = "viewResolver", value = ContentNegotiatingViewResolver.class)
		public ContentNegotiatingViewResolver viewResolver(BeanFactory beanFactory) {
			ContentNegotiatingViewResolver resolver = new ContentNegotiatingViewResolver();
			resolver.setContentNegotiationManager(
					beanFactory.getBean(ContentNegotiationManager.class));
			// ContentNegotiatingViewResolver uses all the other view resolvers to locate
			// a view so it should have a high precedence
			resolver.setOrder(Ordered.HIGHEST_PRECEDENCE);
			return resolver;
		}
```
뷰 리졸버는 WebMvcAutoConfiguration 클래스에 의해 구성된 빈 중 하나다. 위의 코드 단락은 애플리케이션에서 뷰 리졸버를 제공하지 않으면 스프링 부트가 기본 뷰 리졸버를 자동으로 구성한다. 

- @ConditionalOnBean(ViewResolver.class) : ViewResolver.class가 클래스 패스에 있으면 이 빈을 만든다.
- @ConditionalOnMissingBean(name = "viewResolver", value = ContentNegotiatingViewResolver.class) : viewResolver라는 이름의 명시적으로 선언된 빈이 없고, ContentNegotiationViewResolver.class 타입의 빈이 없는 경우 이 빈을 작성한다.
- 나머지 메서드는 뷰 리졸버에서 구성된다.

요약하면, 모든 자동 설정 로직은 스프링 부트 애플리케이션이 구동 시 실행된다. 특정 의존성 또는 스타터 프로젝트의 특정 클래스가 클래스 패스에서 사용할 수 있는 경우, 자동 설정 클래스가 실행된다. 이 자동 설정 클래스는 이미 빈이 구성돼 있는지 확인한다. 기본 빈에 기초해 기본 빈을 작성할 수 있다.