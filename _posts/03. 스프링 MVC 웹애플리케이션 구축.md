스프링 MVC가 컨트롤러, 핸들러 매핑, 뷰 리졸버, POJO 명령 빈에 대한 역할을 명확하게 정의하면, 의존성 주입 및 자동 와이어링과 같은 모든 핵심 스프링 기능을 사용해 웹 애플리케이션을 간단하게 만들 수 있다. 또한 다중 뷰 기술을 지원하므로 확장이 가능하다.

# 자바 웹 애플리케이션 아키텍처
## 모델1 아키텍처
- JSP 페이지는 브라우저에서 요청을 직접 처리했다.
- JSP 페이지는 간단한 자바 빈을 포함하는 모델을 사용했다.
- 이 아키텍처 스타일의 일부 애플리케이션에서는 JSP가 데이터베이스에 대한 쿼리를 수행했다.
- JSP는 다음에 표시할 페이지인 플로 로직을 처리했다.

이 접근법의 많은 단점중 중요한 단점은 다음과 같다.
- 어려운 관점 분리 : JSP는 데이터 검색, 데이터 표시, 다음에 표시할 페이지(흐름) 결정, 때로는 비즈니스 로직까지도 담당했다.
- 복잡한 JSP: JSP가 많은 로직을 처리했기 때문에 거대하고 유지 관리하기가 어려웠다.

## 모델2 아키텍처
모델2 아키텍처는 여러 책임이 있는 복잡한 JSP와 관련된 복잡성을 해결하기 위해 도입됐다. 이것은 MVC 아키텍처 스타일의 기반을 형성한다. 

모델2 아키텍처는 모델, 뷰 및 컨트롤러 간에 명확한 역할 분리를 제공한다. 이는 유지 관리가 쉬운 애플리케이션을 제공한다.
- 모델 : 뷰를 생성하는 데 사용할 데이터를 나타낸다.
- 뷰 : 모델을 사용해 화면을 렌더링한다.
- 컨트롤러 : 흐름을 제어한다. 브라우저에서 요청을 가져와 모델을 채우고 뷰로 리다이렉션 한다.

## 모델2 프런트 컨트롤러 아키텍처
모델2 아키텍처의 기본버전에서 브라우저의 요청은 다른 서블릿(또는 컨트롤러)에 의해 직접 처리된다.
여러 비즈니스 시나리오에서 요청을 처리하기 전에 서블릿에서 일반적인 몇가지 작업을 수행하려 한다. 예를 들면, 로그인한 사용자가 요청을 실행할 수 있는 권한을 갖고있는지 확인하는 것이다.
이것은 모든 서블릿에서 구현하길 원치않는 공통기능이다. 모델2프론터 컨트롤러 아키텍처에서는 모든 요청이 프론트 컨트롤러라는 단일 컨트롤러로 전달된다.

일반적인 프론트 컨트롤러의 책임은 다음과 같다.
- 어떤 컨트롤러가 요청을 실행할지 결정한다
- 렌더링할 뷰를 결정한다
- 좀 더 일반적인 기능을 추가하는 조항을 제공한다
- 스프링 MVC는 프론트 컨트롤러에서 MVC패턴을 사용한다. 프론트 컨트롤러는 DispatcherServlet이다(뒤에서 설명).

# 기본 플로
스프링 MVC는 모델2 프런트 컨트롤러 아키텍처의 수정된 버전을 사용한다. 이 절에서는 스프링MVC로 일반적인 웹앱 플로 6개를 만든다.
* 플로 1: 뷰가 없는 컨트롤러, 자체적으로 콘텐츠 제공
* 플로 2: 뷰가 있는 컨트롤러(JSP)
* 플로 3: 뷰가 있고, ModelMap을 사용하는 컨트롤러
* 플로 4: 뷰가 있고, ModelAndView를 사용하는 컨트롤러
* 플로 5: 간단한 폼의 컨트롤러
* 플로 6: 벨리데이션이 있는 간단한 폼의 컨트롤러

## 기본 설정
다음 절에서는 웹 애플리케이션에서 스프링 MVC 구성을 이해하는 것부터 시작 한다. 의존성을 관리하기 위해 메이븐을 사용하고 있다. 간단한 웹 애플리케이션을 설정하는 단계는 다음과 같다.
1. 스프링 MVC에 대한 의존성을 추가한다
2. DispatcherServlet을 web.xml에 추가한다.
3. 스프링 애플리케이션 콘텍스트를 생성한다.

### 스프링 MVC에 대한 의존성 추가
**pom.xml**에 스프링 MVC 의존성을 추가하는 것부터 시작한다. 다음 코드는 추가할 의존성을 보여준다. 스프링 BOM을 사용하기 때문에 아티팩트 버전을 지정할 필요가 없다.
```xml
<dependency>
    <groupId>org.springframework</groupId>
    <artifactId>spring-webmvc</artifactId>
</dependency>
```
DispatcherServlet은 프런트 컨트롤러 패턴의구현이다. 스프링 MVC에 대한 요청은 프런트 컨트롤러, 즉 DispatcherServlet에 의해 처리될 것이다.

### DispatcherServlet을 web.xml에 추가
이 기능을 사용하려면 DispatcherServlet을 web.xml에 추가해야 한다. 추가하는 방법을 알아보자.
```xml
<servlet>
    <servlet-name>spring-mvc-dispatcher-servlet</servlet-name>
    <servlet-class>org.springframework.web.servlet.DispatcherServlet</servlet-class>
    <init-param>
        <param-name>contextConfigLocation</param-name>
        <param-value>/WEB-INF/user-web-context.xml</param-value>
    </init-param>
    <load-on-startup>1</load-on-startup>
</servlet>
<servlet-mapping>
    <servlet-name>spring-mvc-dispatcher-servlet</servlet-name>
    <url-pattern>/</url-pattern>
</servlet-mapping>
```
첫번째 부분에서는 서블릿을 정의한다. 콘텍스트 구성 위치인 /WEB-INF/user-web-context.xml도 정의하고 있다. 스프링 콘텍스트는 다음 단계에서 정의할 것이다.
두번째 부분에서는 서블릿 매핑을 정의한다. 여기서는 URL /을 DispatcherServlet에 매핑하고 있다. 따라서 모든 요청은 DispatcherServlet에 의해 처리된다.

### 스프링 콘텍스트 생성
web.xml에 DispatcherServlet이 정의됐으므로 스프링 콘텍스트를 만들 수 있다. 처음에는 구체적인 내용을 실제로 정의하지 않고, 매우 간단한 콘텍스트를 만든다.
```xml
<beans>
    <context:component-scan base-package="com.mastering.spring.springmvc" />
    <mvc:annotation-drive />
</beans>
```
com.mastering.spring.springmvc 패키지에 대한 구성 요소 검사를 정의하면, 이 패키지에 모든 빈 및 컨트롤러가 생성되고 오토와이어드 된다.
<mvc:annotation-driven />을 사용하면, 다음과 같이 스프링 MVC가 지원하는 많은 기능에 대한 지원을 초기화 한다.
* 요청 매핑
* 예외 처리
* 데이터 바인딩 및 벨리데이션
* @RequestBody 어노테이션을 사용하는 경우 자동 변환(예:JSON)

이것이 스프링MVC 애플리케이션을 설정하는 데 필요한 모든 설정이다. 이제 첫 번째 플로를 시작할 준비가 됐다.

## 플로 1 - 뷰 없는 간단한 컨트롤러 플로
스프링 MVC 컨트롤러에서 화면에 출력되는 간단한 텍스트를 보여주는 간단한 플로를 시작해보자

### 스프링 MVC 컨트롤러 생성
```JAVA
@Controller
public class BasicController {
    @RequestMapping(value = "/welcome")
    @ResponseBody
    public String welcome() {
        return "welcome to spring MVC";
    }
}
```
* @Controller : 요청 매핑을 포함할 수 있는 스프링 MVC 컨트롤러를 정의한다. URL을 컨트롤러 메서드에 매핑한다.
* @RequestMapping(value="/welcome") : URL /welcome을 welcome 메서드에 매핑하는 것을 정의한다. 브라우저가 /welcome에 요청을 보내면, 스프링 MVC는 welcome 메서드를 실행한다.
* @ResponseBody : 이 특정 콘텍스트에서는 welcome메서드가 반환한 텍스트가 응답 내용으로 브라우저에 전송된다. 특히, @ResponseBody는 REST 서비스의 맥락에서 많은 마법을 수행한다. 이에 대해서는 5장, '스프링 부트로 마이크로 서비스 구축'에서 논의한다.

### 웹 애플리케이션 구동
mvn tomcat7:run 명령을 호출하면 서버를 실행할 수 있다.

### 단위 테스팅
여기서는 스프링 MVC 모킹 프레임워크를 사용해 3장에서 작성할 컨트롤러를 단위 테스트할 것이다. 또한 스프링 MVC 모킹 프레임워크를 사용하기 위해 스프링 테스트 프레임워크에 의존성을 추가한다.
```xml
<dependency>
    <groupId>org.springframework</gorupId>
    <artifactId>spring-test</artifactId>
    <scope>test</scope>
</dependency>
```
여기서는 사용할 접근법은 다음과 같다.
1. 테스트할 컨트롤러 설정하기
2. 테스트 메서드 작성하기

#### 테스트를 위한 컨트롤러 설정
테스트하고자 하는 컨트롤러는 BasicController다. 단위 테스트를 생성하는 관례는 클래스 이름에 접미사로 Test를 붙히는 것이다.
```java
public class BasicControllerTest {
    private MockMvc mockMvc;
    @Before
    public void setup() {
        this.mockMvc = MockMvcBuilder.standaloneSetup(new BasicController()).build();
    }
}
```
* mockMvc : 이 변수는 다른 테스트에서도 사용할 수 있다. 그래서 MockMvc클래스의 인스턴스 변수를 정의한다.
* @Before setup : 이 방법은 모든 테스트 전에 실행돼 MockMvc를 초기화한다.
* MockMvcBuilder.standaloneSetup(new BasicController()).build : 이 코드 라인은 MockMvc 인스턴스를 빌드한다. DispatcherServlet을 초기화해 설정된 컨트롤러인 BasicController로 요청을 처리한다.

#### 테스트 메서드 작성
전체 테스트 메서드는 다음과 같다.
```java
@Test
public void basicTest() throws Exception {
    this.mockMvc
    .perform(get("/welcome")
        .accept(MediaType.parseMediaType("application/html;charset=UTF-8")))
    .andExpect(status().isOk())
    .andExpect( content().contentType("application/html;charset=UTF-8"))
    .andExpect(content().string("Welcome to Spring MVC"));    
}
```
* MockMvc mockMvc.perform : 이 메서드는 요청을 실행하고 체인 호출을 허용하는 ResultActions의 인스턴스를 반환한다. 이 예제에서는 예상한 값을 확인하기 위해 andExpect 호출을 연결한다.
* get("/welcome").accept(MediaType.parseMediaType("applictaion/html;charset=UTF-8")) : 미디어타입이 application/html인 응답을  수신하는 HTTP get 요청을 작성한다.
* andExpect : 이 방법은 예상한 값을 확인하는 데 사용된다. 예상이 맞지 않으면 이 방법은 테스트에 실패한다.
* status().isOk() : ResultMatcher를 사용해 응답상태가 성공적인 요청인지의 여부를 확인한다.(200)
* contentType("application/html;charset=UTF-8") : ResultMatcher를 사용해 응답의 내용 타입이 지정된 대로 있는지 확인한다.
* content().string("Welcome to Spring MVC") : ResultMatcher를 사용해 응답 내용에 지정된 문자열이 들어 있는지 확인한다.


## 플로 2 - 뷰를 가진 간단한 컨트롤러 플로
이전 플로에서는 브라우저에 표시할 텍스트가 컨트롤러에 하드코딩됐다. 브라우저에 표시할 내용은 일반적으로 뷰에서 생성된다. 가장 많이 사용되는 옵션은 JSP다. 여기서는 컨트롤러에서 뷰로 리다이렉션해본다.

### 스프링 MVC 컨트롤러
```java
@Controller
public class BasicViewController {
    @RequestMapping(value="/welcome-view")
    public String welcome() {
        return "welcome";
    }
}
```
* @RequestMapping(value="/welcome-view") : URL /welcome-view 를 매핑한다.
* public String welcome() : 이 메서드에는 @RequestBody 어노테이션이 없다. 따라서 스프링 MVC는 반환된 문자열인 welcome을 뷰와 일치시키려고 시도한다.

### 뷰 생성 - JSP

/src/main/webapp/WEB-INF/views/welcome.jsp
```html
<html>
    <head>
        <title>welcome</title>
    </head>
    <body>
        <p>Welcome!</p>
    </body>
</html>
```
스프링 MVC는 welcome 메서드에서 반환된 문자열을 /WEB-INF/view/welcome.jsp에 있는 실제 JSP로 매핑한다.

#### 뷰 리졸버
뷰 리졸버는 뷰 이름을 실제 JSP페이지로 해석한다. 뷰 리졸버는 스프링 콘텍스트 /WEB-INF/user-web-context.xml에서 구성할 수 있다.
```xml
<bean class="org.springframework.web.servlet.view.InternalResourceViewResolver">
    <property name="prefix">
        <value>/WEB-INF/views/</value>
    </property>
    <property name="suffix">
        <value>.jsp</value>
    </property>
</bean>
```
* org.springframework.web.servlet.view.InternalResourceViewResolver : JSP를 지원하는 뷰 리졸버로, 일반적으로 JstlView가 사용된다. 또한 타일즈(tiles)를 TilesView로 지원한다.
* property prefix/suffix 태그 : 뷰 이름인 welcome은 /WEB-INF/views/welcome.jsp로 해석된다.

### 단위 테스팅
MockMvc 프레임워크의 standalone설정은 DispatcherServlet에 필요한 최소한의 인프라를 생성한다. 뷰 리졸버가 제공되는 경우, 뷰 리솔루션을 실행할 수 있다. 그러나 뷰를 실행하지는 않는다. 따라서 스탠드얼론 설정으로 단위 테스트하는 도중에는 뷰의 내용을 확인할 수 없다. 그러나 올바른 뷰가 전달되는지의 여부는 확인할 수 있다. 이 단위테스트에서는 BasicViewController를 설정하고, /welcome-view에 get 요청을 실행하고, 반환된 뷰 이름이 welcome인지 확인한다. 다음 절에서는 뷰 렌더링을 포함해 통합 테스트를 수행하는 방법을 설명한다. 이 테스트에 관한 한, 뷰 이름을 검증하기 위해 범위를 제한한다.

#### 테스트할 컨트롤러 설정
이 단계는 이전 플로와 매우 유사하다. BasicViewController를 사용해 MockMvc를 인스턴스화한다. 또한 간단한 뷰리졸버를 구성한다.
```java
public class BasicViewControllerTest {
    private MockMvc mockMvc;
    @Before
    public void setup() {
        this.mockMvc = MockMvcBuilders.standaloneSetup(new BasicViewController())
        .setViewResolvers(viewResolver()).build();
    }
    private ViewResolver viewResolver() {
        InternalResourceViewResolver viewReslover = new InternalResourceViewResolver();
        viewResolver.setViewClass(JstlView.class);
        viewResolver.setPrefix("/WEB-INF/jsp/");
        viewResolver.setSuffix(".jsp");
        return viewResolver;
    }
}
```

#### 테스트 메서드 작성
```java
@Test
public void testWelcomeView() throws Exception {
    this.mockMvc
    .perform(get("/welcome-view").accept(MediaType.parseMediaType("application/html;charset=UTF-8")))
    .andExpect(view().name("welcome"));
}
```
* view().name("welcome") : Result Matcher를 사용해 반환된 뷰 이름이 지정된 대로 있는지 확인한다.

## 플로 3 - 모델이 있는 뷰로 전환하는 컨트롤러
일반적으로 뷰를 생성하려면 일부 데이터를 전달해야 한다. 스프링 MVC 에서는 모델을 사용해 뷰에 데이터를 전달할 수 있다. 이 플로에서는 간단한 속성으로 모델을 설정하고, 그 속성을 뷰에서 사용한다.

### 스프링 MVC 컨트롤러
```java
@Controller
public class BasicModelMapController {
    @RequestMapping(value = "/welcome-model-map")
    public String welcome(ModelMap model) {
        model.put("name", "XYZ");
        return "welcome-model-map";
    }
}
```
* public String welcome(ModelMap model) :  추가된 새로운 파라미터는 ModelMap 모델이다. 스프링 MVC는 모델을 인스턴스화해 이 메서드에서 사용할 수 있도록 한다. 모델에 입력된 속성은 뷰에서 사용할 수 있다.

### 뷰 생성
컨트롤러의 모델에 설정된 모델 속성 이름을 사용해 뷰를 생성해보자.
WEB-INF/views/welcome-model-map.jsp
```jsp
Welcome ${name}! This is coming from a model-map -a JSP
```
* ${name} : EL(Expression Language) 구문을 사용해 모델의 속성에 액세스한다.

### 단위 테스트
이 단위테스트에서는 BasicModelMapController를 설정하고 /welcome-model-map에서 get 요청을 실행해 모델이 예상된 속성을 갖고 있는지, 예상된 뷰 이름이 반환되는지의 여부를 확인해야한다.

#### 테스트할 컨트롤러 설정
```java
this.mockMvc = MockBuilders.standaloneSetup(new BasicModelMapController())
                           .setViewResolvers(viewResolver()).build();
```

#### 테스트 메서드 작성
```java
@Test
public void basicTest() throws Exception {
    this.mockMvc.perform(get("/welcome-mode-map").accept(MediaType.parseMediaType("application/html;charset=UTF-8")))
    .andExpect(model().attribute("name", "XYZ"))
    .andExpect(view().name("welcome-model-map"));   
}
```
* model().attribute("name", "XYZ") : 모델이 지정된 값이 XYZ인 특정 속성 이름을 포함하고 있는지 확인하는 Result Matcher

## 플로 4 - ModelAndView를 사용해 뷰로 전환하는 컨트롤러
이전 플로에서는 뷰 이름을 반환하고 뷰에 사용될 속성으로 모델을 채웠다. 스프링 MVC는 ModelAndView를 사용하는 대체 접근법을 제공한다. 컨트롤러 메서드는 모델의 뷰 이름과 적절한 속성을 사용해 ModelAndView 객체를 반환할 수 있다.

### 스프링 MVC 컨트롤러
```java
@Controller
public class BasicModelViewController {
    @RequestMapping(value = "/welcome-model-view")
    public ModelAndView welcome(ModelMap model) {
        model.put("name", "XYZ");
        return new ModelAndView("welcome-model-view", model);
    }
}
```
* public ModelAndView welcome(ModelMap model) : 반환값은 더 이상 스트링이 아니라 ModelAndView이다.

### 뷰 생성
컨트롤러의 모델에 설정된 모델 속성 이름을 사용해 뷰를 생성해보자
/WEB-INF/views/welcome-model-view.jsp
```jsp
Welcome ${name}! This is coming from a model-view - a JSP
```
### 단위테스팅
이 플로의 단위 테스틍인 이전과 유사하다. 예상된 뷰 이름이 반환되는지 확인해야한다.

## 플로 5 - 폼이 있는 뷰로 전환하는 컨트롤러
사용자의 입력을 캡쳐하기 위한 간단한 폼을 만드는 방법
* 간단한 POJO를 만든다. 여기서는 사용자를 만들 것이므로 POJO를 생성한다.
* 2개의 컨트롤러 메서드를 작성한다. 하나는 폼을 표시하는 메서드, 다른 하나는 폼에 입력된 세부 사항을 캡쳐하는 메서드이다.
* 폼으로 간단한 뷰를 작성한다

### 명령 또는 폼 백엔드 오브젝트 작성
POJO는 일반적으로 자바 빈 규칙에 따라 빈을 나타내는데 사용되며, getters, setters 그리고 인수가 없는 생성자를 가진 프라이빗멤버 변수를 포함하고 있다.
```java
public class User {
    private String uid;
    private String name;
    private String userId;
    private String password;
    private String password2;
    //생성자
    //Getter 와 Setters
    //toString
}
```
* 이 클래스에는 어노테이션 또는 스프링 관련 매핑이 없다. 모든 빈은 폼 백엔드 객체로 작동할 수 있다.
* 폼에 이름, 사용자ID 및 암호를 캡처할 것이다.

### 폼을 표시하는 컨트롤러 메서드
로거를 사용해 간단한 컨트롤러를 만드는 것부터 시작한다.
```java
@Controller
public class UserController {
    private Log logger = LogFactory.getLog(UserController.class);
}
```
다음 메서드를 컨트롤러에 추가해보자
```java
@RequestMapping(value="/create-user", method=reuqestMethod.GET)
public String showCreateUserPage(ModelMap model){
    model.addAttribute("user", new User());
    return "user";
}
```
* model.addAttribute("user", new User()) : 빈 폼 백엔드 객체를 사용해 모델을 설정하는 데 사용된다.

### 폼을 가진 뷰 생성
자바 서버 페이지는 스프링 프레임워크에서 지원하는 뷰 기술중 하나다. 스프링 프레임워크를 사용하면 태그 라이브러리를 제공해 뷰를 JSP로 쉽게 만들 수 있다. 여기에는 다양한 폼 요소에 대한 태그, 바인딩, 벨리데이션, 테마 설정 및 메시지 국제화가 포함된다.
이 예제에서는 스프링 MVC태그 라이브러리와 표준 JSTL 태그 라이브러리의 태그를 사용해 뷰를 생성한다.

/WEB-INF/views/user.jsp
```jsp
<%@ taglib uri="http://java.sun.com/jsp/jstl/core" prefix="c" %>
<%@ taglib uri="http://java.sun.com/jsp/jstl/fmt" prefix="fmt" %>
<%@ taglib uri-"http://www.springframework.org/tags/form" prefix="form" %>
<%@ taglib uri="http://www.springframework.org/tags" prefix="spring" %>
```
처음 두 항목은 JSTL 코어 및 서식 태그 라이브러리용이다. 여기서는 스프링 폼 태그를 광범위하게 사용할 것이고, 태그를 지칭하는 접두사를 제공한다.
```jsp
<form:form method="post" modelAttribute="user">
    <fieldset>
        <form:label path="name">Name</form:label>
        <form:input path="name" type="text" required="required" />
    </fieldset>
</form:form>
```

### 컨트롤러가 폼 제출을 처리하는 메서드 가져오기
사용자가 폼 제출하면 브라우저는 HTTP POST 요청을 전송한다.
```java
@RequestMapping(value="/create-user", method=RequestMethod.POST)
public String addTodo(User user) {
    logger.info("user details " + user);
    return "redirect:list-users";
}
```
* public String addTodo(User user) : 스프링 MVC는 폼의 값을 폼 백엔드 객체에 자동으로 바인딩한다.
* return redirect:list-users : 폼을 제출할 때는 일반적으로 DB의 세부 정보를 저장하고, 사용자를 다른 페이지로 리다이렉트 한다. 여기서는 /list-users로 리다이렉팅한다. 스프링 MVC는 리다이렉트를 사용할 때 상태 302와 함께 HTTP응답을 보낸다. 즉, 새 URL로 리다이렉팅한다. 브라우저는 302응답을 처리할 때 사용자를 새 URL로 리다이렉팅한다. POST / REDIRECT / GET 패턴은 중복 폼 제출 문제에 대한 완벽한 방법은 아니지만, 뷰가 렌더링 된 후에 발생하는 경우의 수를 줄여준다.

### 단위 테스팅
다음 플로에서 밸리데이션을 추가할때 단위테스팅 설명 예정.

## 플로 6 - 이전 플로에 밸리데이션 추가
이전 플로에서는 폼을 추가했지만, 폼 값을 확인하지는 않았다. 폼 내용을 벨리데이트 하는 자바스크립트를 작성할 수는 있지만, 서버에서 벨리데이션을 수행하는것이 안전하다.
스프링 MVC는 빈 벨리데이션 API와의 통합을 제공한다. JSR 303과 JSR 349는 빈 벨리데이션 API(각각 버전 1.0과 1.1)에 대한 스펙을 정의한다. 그리고 하이버네이트 벨리데이터는 레퍼런스 구현체다.

### 하이버네이트 벨리데이터 의존성
프로젝트 pom.xml에 하이버네이트 벨리데이터를 추가한다.
```xml
<dependency>
    <groupId>org.hibernate</groupId>
    <artifactId>hibernate-validator</artifactId>
    <version>5.0.2.Fianl</version>
</dependency>
```

### 빈에 대한 간단한 검증
빈 벨리데이션 API는 빈 속성에 지정할 수 있는 여러 가지 벨리데이션을 지정한다.

User클래스
```java
@Size(min = 6, message = "Enter at least 6 characters")
private String name; 
@Size(min = 6, message = "Enter at least 6 characters")
private String userId; 
@Size(min = 8, message = "Enter at least 6 characters")
private String password; 
@Size(min = 8, message = "Enter at least 6 characters")
private String password2; 
```
* @Size(min = 6, message = "Enter at least 6 characters") : 이 필드는 최소 여섯자 이상이어야 한다. 밸리데이션을 통과하지 못하면 메시지 속성의 텍스트가 벨리데이션 에러 메시지로 사용된다.

빈 벨리데이션을 사용해 수행할 수 있는 다른 벨리데이션은 다음과 같다.
* @NotNull
* @Size(min=5, max=50)
* @Past : 과거의 날짜여야 한다
* @Future : 미래의 날짜여야 한다
* @Pattern : 제공된 정규 표현식과 일치해야 한다
* @Max : 필드의 최대값
* @Min : 필드의 최솟값

이제 컨트롤러 메서드를 가져와 폼을 벨리데이트 하는데 집중하자.
```java
@RequestMapping(value = "/create-user-with-validation", method=RequestMethod.POST)
public String addTodo(@Valid User user, BindingResult result) {
    if(result.hasErrors()) {
        return "user";
    }
    logger.info("user details " + user);
    return "redirect:list-users";
}
```
* public String addTodo(@Valid User user, BindingResult result) : @Valid 어노테이션이 사용되면, 스프링 MVC는 빈을 벨리데이트 한다. 벨리데이션 결과는 BindingResult 인스턴스 결과에서 사용할 수 있다.
* if(result.hasErrors()) : 벨리데이션에 에러가 있는지 확인한다.

벨리데이션 에러가 발생할 경우에는 벨리데이션 메시지를 표시하기 위해 user.jsp를 수정해야 한다.
```jsp
    <fieldset>
        <form:label path="name">Name</form:label>
        <form:input path="name" type="text" required="required" />
        <form:errors path="name" cssClass="text-warning" />
    </fieldset>
```
* <form:errors path="name" cssClass="text-warning" /> : 경로에 지정된 필드 이름과 관련된 오류를 표시하는 스프링 폼 태그다. 벨리데이션 에러를 표시하는 데 사용되는 css클래스를 지정할 수도 있다.

### 커스텀 벨리데이션
@AssertTrue 어노테이션을 사용해 좀 더 복잡한 커스텀 벨리데이션을 구현할 수 있다.
다음은 User 클래스에 추가된 예제 메서드 목록이다.
```java
@AssertTrue(message = "Password fields not match")
private boolean isValid() {
    return this.password.equals(this.password2);
}
```
@AssertTrue(message = "Password fields not match") 는 벨리데이션이 실패했을 경우에 표시할 메시지다. 이런 식으로 다중 필드의 복잡한 벨리데이션 로직을 구현할 수 있다.

### 단위 테스팅
이 부분에 대한 단위 테스팅은 벨리데이션 에러를 확인하는데 중점을 둔다. 여기서는 4개의 벨리데이션 에러를 확인하는 빈 폼에 대한 테스트를 작성할 것이다.

#### 컨트롤러 설정
```java
this.mockMvc = MockMvcBuilders.standaloneSetup(new UserValidationController()).build();
```

#### 테스트 메서드
```java
@Test
public void basicTest_WithAllValidationErrors() throws Exception {
    this.mockMvc.perform(post("/create-user-with-validation").accetp(MediaType.parseMediaType("application/html;charset=UTF-8")))
    .andExpect(status().isOk())
    .andExpect(model().errorCount(4))
    .andExpect(model().attributeHasFieldErrorCode("user","name","Size"));
}
```
* post("/create-user-with-validation") : 요청파라미터를 전달하지 않으므로 모든 속성은 null이다. 이경우, 벨리데이션 에러가 발생한다.
* model().errorCount(4) : 모델에 4개의 벨리데이션 에러가 있는지 점검한다.
* model().attributeHasFieldErrorcode("user", "name", "Size") : user 속성에 Size라는 벨리데이션 에러가 있는 name필드가 있는지 확인한다.

# 스프링 MVC의 개요

## 중요 기능
* 각 객체에 대해 잘 정의된 독립적인 역할을 가진 느슨하게 결합된 아키텍처다.
* 유연한 컨트롤러 메서드 정의다. 컨트롤러 메서드는 다양한 범위의 파라미터와 반환값을 가질 수 있다. 이는 프로그래머가 자신의 필요에 맞는 정의를 선택할 수 있는 유연성을 제공한다.
* 도메인 객체를 폼 백엔드 객체로 재사용할 수 있다. 별도의 서식 객체를 가져야할 필요성이 줄어든다
* 현지화를 지원하는 태그 라이브러리(스프링, 스프링-폼)가 내장돼있다.
* 모델은 키-값 쌍과 함께 해시맵을 사용한다. 여러 뷰 기술과의 통합을 허용한다.
* 유연한 바인딩이다. 바인딩하는 동안 불일치되는 타입은 런타임에러대신 벨리데이션 에러로 해결할 수 있다.
* 단위테스트 컨트롤러에 모크 MVC 프레임워크가 포함돼있다.

## 어떻게 작동할까?
예제 플로를 살펴보고, 플로 실행과 관련된 여러 가지 단계를 이해해보자. 여기서는 플로4를 통해 ModelAndView를 반환할 것이다. 플로 4의 URL은 http://localhost:8080/welcome-model-view다. 다른 단계는 다음과 같다.
1. 브라우저는 특정 URL에 요청을 보낸다. DispatcherServlet은 모든 요청을 처리하는 프런트 컨트롤러다. 그래서 DispatcherServlet이 요청을 받는다.
2. Dispatcher Servleet은 URI를 보고, 이를 처리하기 위해 올바른 컨트롤러를 식별해야 한다. 올바른 컨트롤러를 찾는데 도움을 주기 위해 핸들러 매핑과 통신한다.
3. 핸들러 매핑은 요청을 처리하는 특정 핸들러 메서드(예:BasicModelViewController의 welcome메서드)를 반환한다.
4. DispatcherServlet은 특정 핸들러메서드(public ModelAndView welcome(ModelMap model))를 호출한다.
5. 핸들러 메서드는 모델과 뷰를 반환한다. 이 예제에서는 ModelAndView 객체가 반환된다.
6. DispatcherServlet에는 논리적 뷰 이름(ModelAndView에서 가져온 것, 이 예에서는 welcome-model-view)이 있다. 따라서 물리적 뷰 이름을 결정하는 방법을 알아내야 한다. 사용할 수 있는 뷰 리졸버가 있는지의 여부를 확인한다. 설정된 뷰 리졸버를 찾는다(org.springframework.web.servlet.view.InternalResourceViewResolver). 뷰 리졸버를 호출해 논리적 뷰 이름(이 예제에서는 welcome-model-view)을 입력으로 제공한다.
7. 뷰 리졸버는 논리적 뷰 이름을 물리적 뷰 이름에 매핑하는 로직을 실행한다. 이 예에서는 welcome-model-view는 /WEB-INF/views/welcome-model-view.jsp로 변환된다.
8. DispatcherServlet은 뷰를 실행한다. 또한 뷰에서 모델을 사용할 수 있게 한다.
9. 뷰는 DispatcherServlet으로 보내질 내용을 반환한다.
10. DispatcherServlet은 응답을 다시 브라우저로 보낸다.


# 스프링 MVC의 핵심 개념
## RequestMapping
RequestMapping은 앞의 예제에서 설명한 것처럼 URI를 컨트롤러 또는 컨트롤러 메서드에 매핑하는 데 사용된다. 클래스 및/또는 메서드 레벨에서 수행할 수 있다. 선택적 메서드 파라미터를 사용하면 메서드를 특정 요청 메서드(GET, POST 등)에 매핑할 수 있다.

### 요청 매핑 예제
#### 예제1
다음 예제에서는 showPage 메서드에 하나의 RequestMapping만 있다. showPage메서드는 GET, POST 및 URI /show-page에 대한 다른 요청 타입에 매핑된다
```java
@Controller
public class UserController {
    @RequestMapping(value = "/show-page")
    public String showPage() {
    }
}
```

#### 예제2
다음 예제에서는 showPage메서드는 /show-page 에 대한 GET요청만 매핑된다.
```java
@Controller
public class UserController {
    @RequestMapping(value = "/show-page", method = RequestMethod.GET)
    public String showPage(){
    }
}
```

#### 예제3
다음 예제에는 2개의 RequestMapping 메서드가 있다. 하나는 클래스, 다른 하나는 메서드에 있다. 두 가지 RequestMapping 메서드의 조합은 URI를 결정하는데 사용된다.
showPage 메서드는 URI /user/show-page에 대한 GET 요청에만 매핑된다.
```java
@Controller
@RequestMapping("/user")
public class UserController {
    @RequestMapping(value = "/show-page", method= RequestMethod.GET)
    public String showPage() {

    }
}
```

### 요청 매핑 메서드 - 지원되는 메서드 인수
다음은 요청 매핑이 있는 컨트롤러 메서드에서 지원되는 인수 타입 중 일부다.

|인수 타입/어노테이션|사용|
|---|---|
|java.util.Map / org.springframework.ui.Model / org.springframework.ui.ModelMap|뷰에 노출될 값으 모델(MVC)역할을 한다.|
|Command or form objects|요청 파라미터를 빈에 바인딩하는 데 사용된다. 벨리데이션도 지원한다.|
|org.springframework.validation.Errors / org.springframework.validation.BindingResult|명령 또는 폼 객체의 벨리데이션 결과(폼 객체는 바로 앞의 메서드 인수여야 한다.|
|@PreDetroy|predestroy메서드는 모든 스프링 빈에서 @PreDestroy 어노테이션을 사용해 제공된다. 이 메서드는 빈이 컨테이너에서 제거되기 전에 호출된다. 빈에 의해 유지되는 모든 자원을 해제할 수 있다.|
|@RequestParam|특정 http 요청 파라미터에 액세스하기 위한 어노테이션|
|@RequestHeader|특정 http 요청 헤더에 액세스하기 위한 어노테이션|
|@SessionAttribute|HttpSession으로부터 속성을 액세스하기 위한 어노테이션|
|@RequestAttribute|특정 http 요청 속성에 액세스하기 위한 어노테이션|
|@PathVariable|어노테이션은 URI 템플릿인 ./owner/{ownerId}의 변수에 대한 액세스를 허용한다. 마이크로서비스에 관해 논의할 때 이 점을 깊이 살펴보라|

### RequestMapping 메서드 - 지원되는 리턴 타입
RequestMapping 메서드는 다양한 리턴 타입을 지원한다. 요청 매핑 메소드는 다음과 같은 두가지 질문에 대답해야 한다.
* 뷰는 무엇일까?
* 뷰에 필요한 모델은 무엇일까?

그러나 스프링 MVC를 사용하면 항상 뷰와 모델을 명시적으로 선언할 필요가 없다.
* 뷰가 리턴 타입의 일부로 명시적으로 정의되지 않은 경우, 이는 암묵적으로 정의된다
* 모든 모델 객체는 다음 규칙에 자세히 설명돼 있다.

스프링 MVC는 간단한 규칙을 사용해 정확한 뷰와 모델을 결정한다. 중요한 규칙은 다음과 같다.
* 모델의 암묵적 풍부화 : 모델이 리턴 타입의 일부인 경우, 명령 객체(명령 객체의 벨리데이션 결과 포함)가 풍부해진다. 또한 @ModelAttribute 어노테이션이 있는 메서드의 결과도 모델에 추가된다.
* 뷰의 암묵적 결정 : 뷰 이름이 리턴 타입에 없으면 DefaultRequestToViewNameTranslator를 사용해 결정한다. 기본적으로 DefaultRequestToViewNameTranslator는 URI 에서 파일 확장명과 함께 선행 및 후행 슬래시를 제거한다. 예를 들어, display.html이 표시된다.

다음은 요청 매핑이 있는 컨트롤러 메서드에서 지원되는 리턴 타입 중 일부다.
|리턴 타입|무엇이 일어났는가?|
|---|---|
|ModelAndView|객체에는 모델 및 뷰 이름에 대한 참조가 포함된다|
|Model|모델만 반환된다. 뷰 이름은 DefaultRequestToViewNameTranslator를 사용해 결정한다.|
|Map|모델을 노출하는 간단한 맵|
|View|암묵적으로 정의된 모델이 있는 뷰|
|String|뷰 이름에 대한 참조|

## 뷰 리솔루션
스프링MVC는 여러 뷰 옵션을 제공한다.
* JSP, 프리마커와의 통합
* 다중 뷰 분석 전략으로, 그 중 일부는 다음과 같다.
> * XmlViewResolver : 외부 XML구성을 기반으로 한 뷰 리솔루션
> * ResourceBundleViewResolver : 속성 파일을 기반으로 한 뷰 리솔루션
> * UrlBasedViewResolver : 논리적 뷰 이름을 URL로 직접 매핑
> * ContentNegotiatingViewResolver : Accept 요청 헤더를 기반으로 다른 뷰 리졸버로 위임
* 명시적으로 정의된 선호 순서로 뷰 리졸버의 체인 지원
* 콘텐츠 네고시에이션을 사용해 XML, JSON 및 Atom을 직접 생성

### JSP 뷰 리졸버 구성
다음 예제는 InternalResourceViewResolver를 사용해 JSP 뷰 리졸버를 구성하기 위한 일반적인 사용 방법이다. 물리적 뷰 이름은 JstlView에서 사용된 논리적 뷰 이름의 접두사 및 접미사를 사용해 결정한다.
```xml
<bean id="jspViewResolver" class="org.springframework.web.servlet.view.InternalResourceViewResolver">
    <property name="viewClass" value="org.springframework.web.servlet.view.JstlView" />
    <property name="prefix" value="/WEB-INF/jsp/" />
    <property name="suffix" value=".jsp" />
</bean>
```
매핑을 위해 속성과 XML파일을 사용하는 데에는 다른 방법도 있다.

### 프리마커 구성
다음 예는 프리마커 뷰 리졸버를 구성하는 데 사용하는 일반적인 접근법을 보여준다. 먼저 freemarkerConfig빈은 프리마커 템플릿을 로드하는 데 사용된다.
```xml
<bean id="freemarkerConfig" class="org.springframework.web.servlet.view.freemarker.FreeMarkerConfigurer">
    <property name="templateLoaderPath" value="/WEB-INF/freemarker/" />
</bean>
```
다음은 Freemarkerviewresolver를 구성하는 방법이다
```xml
<bean id="freemarkerViewResolver" class="org.springframework.web.servlet.view.freemarker.FreeMarkerViewResolver">
    <property name="cache" value="true" />
    <property name="prefix" vlaue="" />
    <property name="suffix" value=".ftl" />
</bean>
```
뷰 리솔루션은 jsp와 마찬가지로 속성 또는 xml파일을 사용해 정의할 수 있다.

## 핸들러매핑과 인터셉터
스프링 2.5 이전 버전(어노테이션 지원되기 전)에서는 URL과 컨트롤러(핸들러라고도 함)간의 매핑이 핸들러 매핑이라는 것을 사용해 표현됐다. 어노테이션을 사용하면 명시적인 핸들러 매핑이 필요하지 않다. HandlerInterceptor는 핸들러(또는 컨트롤러)에 대한 요청을 인터셉트하는 데 사용된다. 때로는 요청 전후에 일부 처리를 원할 수 있다. 요청 및 응답의 내용을 기록하거나 특정 요청의 소요된 시간을 알아내야 할 수도 있다. HandlerInterceptor를 만드는 데는 두 가지 단계가 있다.
1. HandlerInterceptor를 정의한다.
2. HandlerInterceptor를 인터셉트할 특정 핸들러에 매핑한다.

### HandlerInterceptor 정의
다음은 HandlerInterceptorAdapter에서 재정의할 수 있는 메서드다.
* public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) : 핸들러가 호출되기 전에 호출된다.
* public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView mav) : 핸들러가 호출된 후 호출된다. view가 렌더링 되기 전 수행
* public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) : 요청 처리가 완료된 후에 호출된다. view가 정상적으로 렌더링 된 후 제일 마지막.

다음 구현 예는 HandlerInterceptor를 생성하는 방법이다.
```java
public class HandlerTimeLoggingInterceptor extends HandlerInetrceptorAdapter {
    //핸들러 호출 시작 시간 요청에 추가
    @Override
    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception {
        request.setAttribute("startTime", System.currentTimeMillis());
        return true;
    }
    // 핸들러 호출의 종료시간 추가
    @Override
    public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView mav) throws Exception {
        request.setAttribute("endTime", System.currentTimeMillis());
        return true;
    }
    // 핸들러에서 처리한 시간 확인
    @Override
    public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception {
        long startTime = (Long) request.getAttribute("startTime");
        long endTime = (Long) request.getAttribute("endTime");
        logger.info("Time spent in Handler in ms : " + (endTime-startTime));
    }
}
```

### HandlerInterceptor를 핸들러에 매핑
HandlerInterceptors는 인터셉트하고자 하는 특정 URL에 매핑될 수 있다. 다음 예제는 xml콘텍스트 구성 예제다. 인터셉터는 기본적으로 모든 핸들러(컨트롤러)를 인터셉트한다.
```xml
<mvc:interceptors>
    <bean class="com.mastering.spring.springmvc.controller.interceptor.HandlerTimeLoggingInterceptor" />
</mvc:interceptors>
```
정확한 URI를 인터셉트할 수 있도록 수성할 수 있다. 다음은 /secure/로 시작하는 URI매핑이 있는 핸들러를 제외한 모든 핸들러를 인터셉트한다.
```xml
<mvc:interceptors>
    <mapping path="/**" />
    <exclude-mapping path="/secure/**" />
    <bean class="com.mastering.spring.springmvc.controller.interceptor.HandlerTimeLoggingInterceptor" />
</mvc:interceptors>
```

## 모델 속성
일반적인 웹 폼에는 주 목록, 국가 목록 등 여러 가지 드롭다운 값이 있다. 이 값이 뷰에서 목록으로 표시될 수 있도록 모델에서 사용할 수 있어야 한다. 이러한 작업은 일반적으로 @ModelAttribute 어노테이션으로 표시된 메서드를 사용해 모델에 채워진다.

이에는 가능한 두 가지 베리에이션이 있다. 다음 예제에서 메서드는 모델에 넣어야 하는 객체를 반환한다.
```java
@ModelAttribute
public List<State> populateStateList() {
    return stateService.findStates();
}
```
이 예제의 접근법은 여러 속성을 모델에 추가하는 데 사용된다.
```java
@ModelAttribute
public void populateStateAndCountryList() {
    model.addAttribute(stateService.findStates());
    model.addAttribute(countryService.findCountries());
}
```
주목해야 할 점은 @ModelAttribute 어노테이션으로 표시할 수 있는 메서드 수에 제한이 없다는 것이다. 컨트롤러 어드바이스를 사용하면 여러 컨트롤러에서 모델 속성을 공통으로 지정할 수 있다. 컨트롤러 어드바이스는 추후 설명.

## 세션 속성
지금까지 논의한 모든 속성과 값은 단일 요청 내에서 사용된다. 급사용자 구성과 같은 요청 간에 변경되지 않는 값이 있을 수 있다. 이러한 종류의 값은 일반적으로 HTTP 세션에 저장된다. 스프링 MVC는 세션에 저장되는 속성을 지정하는 단순 타입레벨(클래스 레벨)의 @SessionAttribute 어노테이션을 제공한다.
```java
@Controller
@SessionAttributes("exampleSessionAttribute")
public class LoginController{} 
```

### 세션에 속성 추가
@SessionAttributes 어노테이션 속성을 정의하면, 동일한 속성이 모델에 추가되는 경우 세션에 자동으로 추가된다. 아ㅔ서 exapleSessionAttribute라는 이름의 속성을 모델에 넣으면 세션 대화 상태로 자동 저장된다
```java
model.put("exampleSessionAttribute", sessionValeu);
```

### 세션에서 속성 읽기
이 값은 먼저 @SessionAttributes 어노테이션을 타입 레벨에서 지정해 다른 컨트롤러에서 엑세스할 수 있다.
```java
@Controller
@SessionAttributes("exampleSessionAttribute")
public class SomeOtherController{}
```

세션 속성의 값은 모든 모델 객체에서 직접 사용할 수 있다. 따라서 모델에서 액세스할 수 있다.
```java
Value sessionValue = (Value)model.get("exampleSessionAttribute");
```

### 세션에서 속성 제거
세션 대화 상태에서 값을 제거하는 데에는 두 가지 방법이 있다. 첫 번째 방법은 다음 코드에서 설명한다. WebRequest클래스에서 사용할 수 있는 removeAttribute 메서드를 사용한다.
```java
@RequestMapping(value="/some-method", method=RequestMethod.GET)
public String someMethod( /* Other Parameters */
    WebRequest request, SessionStatus status) {
    status.setComplete();
    request.removeAttribute("exampleSessionAttribute", WebRequest.SCOPE_SESSION);
    //other logic
}
```
이 예제는 SessionAttributeStore에서 cleanUpAttribute 메서드를 사용하는 두 번째 방법이다.
```java
@RequestMapping(value="/some-other-method", method=RequestMethod.GET)
public String someOtherMethod( /*Other Parameters*/
SessionAttributeStore store, SessionStatus status) {
    status.setComplete();
    store.cleanupAttribute(request, "exampleSessionAttribute");
    //Other logic
}

## InitBinders
폼의 값은 폼 백엔드 객체에 바인딩돼야한다. @InitBinder 어노테이션을 사용하면 바인딩이 어떻게 발생하는지 커스텀할 수 있다. 또한 핸들러 어드바이스를 사용하면 특정 컨트롤러 또는 컨트롤러 세트에서 커스텀을 수행할 수 있다. 다음 예제는 폼 바인딩에 사용할 기본 날짜 형식을 설정하는 방법이다.
```java
@InitBinder
protected void initBinder(WebDataBinder binder){
    SimpleDateFormat dateFormat = new SimpleDateFormat("dd/MM/yyyy");
    binder.registerCustomEditor(Date.class, new CustomDateEditor(dateFormat, false));
}
```

## @ControllerAdvice 어노테이션
컨트롤러 레벨에서 정의한 기능 중 일부는 애플리케이션에서 공통적으로 나타날 수 있다. 예를 들어, 애플리케이션에서 동일한 날짜 형식을 사용하고자 할 수 있다. 따라서 앞에서 정의한 @InitBinder를 애플리케이션 전체에 적용할 수 있다. @ControllerAdvice는 기본적으로 모든 요청매핑에서 공통된 기능을 제공한다. 다음 예제에서 메서드에 정의된 바인딩은 모든 요청 매핑에 적용할 수 있다.
```java
@ControllerAdvice
public class DateBindingControllerAdvice {
    @InitBinder
    protected void initBinder(WebDataBinder binder){
        SimpleDateFormat dateFormat = new SimpleDateFormat("dd/MM/yyyy");
        binder.registerCustomEditor(Date.class, new CustomDateEditor(dateFormat, false));
    }
}
```
컨트롤러 어노테이션은 공통 모델 속성(@ModelAttribute) 및 일반적인 예외 처리(@ExceptionHandle)를 정의하는 데 사용할 수도 있다. 적절한 어노테이션으로 표시된 메서드를 작성하면 된다. 예외 처리는 다음절에서...

# 스프링 MVC - 고급기능
## 예외 처리
애플리케이션에서 일관된 예외 처리 전략을 갖는 것은 매우 중요하다. 잘 설계되고 작성된 애플리케이션에도 예외 처리가 필요하다. 스프링 출현 전에도 체크된 예외를 광범위하게 사용하기 위해 애플리케이션 코드에서 예외처리 코드가 필요했다. 예를들어, 대부분의 JDBC메서드는 체크된 예외를 발생시키기 때문에 모든 메서드에서는 예외를 처리하기 위한 try-catch가 필요하다(메서드가 jdbc예외를 발생시킨다고 선언하지 않는 한). 스프링 프레임워크에서는 예외의 대부분이 언체크된 예외로 만들어졌다. 특정 예외 처리가 필요 없는 경우, 일반적으로 애플리케이션에서 예외를 처리할 수 있다.

* 모든 컨트롤러에서 발생하는 일반적인 예외 처리
* 컨트롤러에 대한 특정 예외 처리

### 컨트롤러 전반의 일반적인 예외 처리
컨트롤러 어드바이스는 컨트롤러 전반에서 일반적인 예외 처리를 구현하는 데에도 사용할 수 있다.
```java
@ControllerAdvice
public class ExceptionController {
    private Log logger = LogFactory.getLog(ExceptionController.class);
    @ExceptionHandler(value = Exception.class)
    public ModelAndView handleException(HttpServletRequest request, Exception ex) {
        logger.error("Request " + request.getRequestURL() + " Threw an exception", ex);
        ModelAndView mav = new ModelAndView();
        mav.addObject("exception", ex);
        mav.addObject("url", request.getRequestURL());
        mav.setViewName("common/spring-mvc-error");
        return mav;
    }
}
```
* @ControllerAdvice : 컨트롤러 어드바이스는 기본적으로 모든 컨트롤러에 적용할 수 있다.
* @ExceptionHandler( value= Exception.class ) : 이 어노테이션이 있는 메서드는 지정된 클래스(Exception.class)의 타입 또는 서브-타입에 대한 예외가 컨트롤러에서 발생할 때 호출된다.
* public ModelAndView handleException(HttpServletRequest request, Exception ex) : 발생된 예외는 Exception 변수에 삽입된다. 메서드는 예외 세부 사항 및 예외 뷰가 모델로 반환될 수 있도록 ModelAndView 리턴타입으로 선언한다.
* mav.addObject("exception", ex) : 예외 정보를 뷰에 표시할 수 있도록 모델에 예외를 추가한다.
* mav.setViewName("common/spring-mvc-error") : 예외 뷰다.

#### 에러 뷰
ExceptionController는 예외가 발생할 때마다 모델에 예외 세부 사항을 채운 후에 ExceptionController spring-mvc-error 뷰로 사용자를 리다이렉트 한다. 다음 코드는 완전한 /WEB-INF/views/common/spring-mvc-error.jsp를 보여준다.
```jsp
<%@ taglib prefix="c" uri="http://java.sun.com/jsp/jstl/core"%>
<%@page isErrorPage="true"%>
<h1>Error Page</h1>
URL : ${url}
<BR />
Exception : ${exception.message}
<c:forEach items="${exception.stackTrace}" var="exceptionStackTrace">
${exceptionStackTrace}
</c:forEach>
```
* URL : ${url} : 모델의 URL을 표시한다
* 예외 : ${exception.message} : 예외 메시지를 표시한다. 예외는 ExceptionController에서 모델에 채워진다.
* forEach around ${exceptinoStackTrace} : ExceptionController의 특정한 예외 처리에서 스택 추적을 표시한다.

### 컨트롤러의 특정 예외 처리
일부 상황에서는 컨트롤러에서 특정 예외 처리가 필요하다. 이 상황은 @ExceptionHandler(value=Exception.class)로 어노테이션된 메서드를 구현해 쉽게 처리할 수 있다. 특정 예외 처리가 필요한 경우에는 특정 예외 클래스를 어노테이션의 value 속성에 대한 값으로 제공할 수 있다.

## 국제화
애플리케이션을 개발할 때는 여러 로케일에서 사용할 수 있길 원한다(국제화 or 현지화). 이는 두 가지 접근법을 사용해 구현할 수 있다.
* SessionLocaleResolver
* CookieLocaleResolver

SessionLocaleResolver의 경우, 사용자가 선택한 로케일은 사용자 세션에 저장되므로 사용자 세션에만 유효하다. 그러나 CookieLocaleResolver의 경우에 선택한 로케일은 쿠키에 저장된다.

### 메시지 번들 설정
먼저, 메시지 번들러를 설정해보자. 스프링 콘텍스트 코드는 다음과 같다.
```xml
<bean id="messageSource" class="org.springframework.context.support.ReloadableResourceBundleMessageSource">
    <property name="basename" value="classpath:messages" />
    <property name ="defaultEncoding" value="UTF-8" />
</bean>
```
* class="org.springframework.context.support.ReloadableResourceBundleMessageSource" : 리로드할 수 있는 리소스 번들을 구성 중이다. cacheSeconds 설정을 통해 속성 리로드를 지원한다.
* <property name="basename" value="classpath:messages" /> : messages.properties 및 messages_{locale}.properties 파일에서 속성 파일 로딩을 구성한다. 로케일에 대해서는 곧 논의할 것이다.

2개의 속성 파일을 구성해 src/main/resources 폴더에 넣고 사용해보자
```
message_en.properties
welcome.caption=Welcome in English
message_fr.properties
welcome.caption=Bienvenue - Welcome in French
```
spring: message 태그를 사용하면 뷰에서 메시지 번들의 메시지를 표시할 수 있다.
```xml
<spring:message code="welcome.caption" />
```

### SessionLocaleResolver 구성
SessionLocaleResolver를 구성하는 데에는 두 가지 방법이 있다. 첫번째는 localeResolver를 구성하는것이고, 두번째는 로케일에서 변경을 처리하도록 인터셉터를 구성하는 것이다.
```xml
<bean id="springMVCLocaleResolver" class="org.springframework.web.servlet.i18n.SessionLocaleResolver">
    <property name="defaultLocale" value="en" />
</bean>
<mvc:interceptors>
    <bean id="springMVCLocaleChangeInterceptor" class="org.springframework.web.servlet.i18n.LocaleChangeInterceptor">
        <property name="paramName" value="language" />
    </bean>
</mvc:interceptors>
```
* <property name="defaultLocale" value="en" /> : 기본적으로 en 로케일이 사용된다.
* <mvc:interceptors> : LocaleChangeInterceptor는 HandlerInterceptor로 설정된다. 모든 핸들러 요청을 차단하고 로케일을 확인한다.
* <property name="paramName" value="language" /> : LocaleChangeInterceptor는 locale을 나타내는 language라는 요청 파라미터 이름을 사용하도록 구성된다. 따라서 http://server/uri?language={locale} 형식의 모든 URL이 로케일 변경을 일으킨다.
* language=en 을 URL에 추가하면 세션 기간 동안 en로케일을 사용하게 된다. 

### CookieLocaleResolver 구성
```xml
<bean id="localeResolver" class="org.springframework.web.servlet.i18n.CookieLocaleResolver">
    <property name="defaultLocale" value="en" />
    <property name="cookieName" value="userLocaleCookie" />
    <property name="cookieMaxAge" value="7200" />
</bean>
```
* <property name="cookieName" value="userLocaleCookie" /> : 브라우저에 저장된 쿠키의 이름은 userLocaleCookie다
* <property name="cookieMaxAge" value="7200" /> : 쿠키의 수명은 2시간(7200초) 이다.
* 앞의 예제에서 LocaleChangeInterceptor를 사용하고 있기 때문에 language=en을 URL에 추가하면 en로케일을 2시간 동안(또는 로케일이 변경될 때까지)사용하게 된다.

## 스프링 컨트롤러 통합 테스트
논의한 플로에서는 실제 단위테스트를 사용해 살펴봤다. 또 다른 가능성은 전체 스프링 콘텍스트를 로드하는 것이다. 그러나 전체 콘텍스트를 로드할 때 통합테스트가 더 필요하다. 다음 코드는 스프링 콘텍스트를 완전히 시작하고, 모든 컨트롤러를 시작하는 방법을 보여준다
```java
@RunWith(SpringRunner.class)
@WebAppConfiguration
@ContextConfiguration("file:src/main/webapp/WEB-INF/user-web-context.xml")
public class BasicControllerSpringConfigurationIT {
    private MockMvc mockMvc;
    @Autowired
    private WebApplicationContext wac;
    @Before
    public void setup() {
        this.mockMvc = MockMvcBuilders.webAppContextSetup(this.wac).build();
    }
    @Test
    public void basicTest() throws Exception {
        this.mockMvc.perform(get("/welcome").accept(MediaType.parseMediaType("application.html;charset=UTF-8")))
        .andExcept(status().isOk())
        .andExpect(content().string("Welcome to Spring MVC"));
    }
}
```
* @RunWith(SpringRunner.class) : SpringRunner는 스프링 콘텍스트를 시작하는 데 도움이 된다.
* @WebAppConfiguration : 스프링 MVC로 웹 애플리케이션 콘텍스트를 시작하는 데 사용된다.
* @ContextConfiguration("file:src/main/webapp/WEB-INF/user-web-context.xml") : 스프링 콘텍스트 XML의 위치를 지정한다.
* this.mockMvc = MockMvcBuilders.webAppContextSetup(this.wac).build() : 이전 예제에서는 스탠드얼론 설정을 사용했다. 그러나 이 예에서는 전체 웹 앱을 시작하려고 한다. 그래서 webAppContextSetup을 사용한다.
* 테스트의 실행은 이전 테스트에서 수행한 것과 매우 유사하다.

## 정적 자원 제공
프론트엔드 프레임워크에서의 진화와 함께, 프론트엔드 정적 콘텐츠를 버전화하고 제공하는 데 적합한 솔루션을 찾는것이 매우 중요하다. 스프링 MVC프레임워크가 제공하는 중요한 기능은 다음과 같다.
* 웹애플리케이션 루트 폴더에서 정적 콘텐츠를 노출한다.
* 캐싱을 가능하게 한다.
* 정적 콘텐츠의 GZip압축을 가능하게 한다.

### 정적 콘텐츠 노출
웹 애플리케이션에는 대개 정적 콘텐츠가 많다. 스프링 MVC는 클래스 패스의 위치뿐 아니라 웹 애플리케이션 루트 폴더에서 정적 콘텐츠를 노출하는 옵션을 제공한다. 다음 단락은 war파일 내의 콘텐츠가 정적 콘텐츠로 노출될 수 있다는 것을 보여준다.
```xml
<mvc:resources mapping="/resources/**" location="/static-resources/" />
```
* location="/static-resouces/" : 위치는 정적 콘텐츠로 표시하려는 war파일 또는 클래스 패스 내부의 폴더를 지정한다. 이 예제에서는 war파일 루트에 있는 statc-resources 폴더의 모든 콘텐츠를 정적 콘텐츠로 표시하려고 한다. 여러 개의 쉼표로 구분된 값을 지정해 동일한 외부지향 URI를 아래의 여러 폴더로 표시할 수 있다.
* mapping="/resouces/**" : 매핑은 외부 방향 URI경로를 지정한다. 따라서 정적자원폴더 내의 app.css라는 CSS파일은 /resources/app.css를 사용해 액세스 할 수 있다.

동일한 구성을 자바로 하면 다음과 같다
```java
@Configuration
@EnableWebMvc
public class WebConfig extends WebMvcConfigurerAdapter {
    @Override
    public void addResourceHandlers(ResourceHandlerRegistry registry) {
        registry.addResourceHandler("/resources/**")
        .addResourceLocations("/static-resocurces/");
    }
}
```

### 정적 콘텐츠 캐싱
정적 리소스에 대한 캐싱을 사용하면 성능을 향상시킬 수 있다. 브라우저는 지정된 기간동안 게재된 리소스를 캐싱한다. cache-period 속성 또는 setCachePeriod 메서드는 사용된 구성 타입에 따라 캐싱 간격(초)을 지정하는 데 사용할 수 있다. 다음은 자바 구성이다
```java
registry.addResourceHandler("resources/**")
.addResourceLocations("/static-resources/")
.setCachePeriod(365*24*60*60);
```
다음은 xml구성이다
```xml
<mvc:resources mapping="/resources/**" location="/static-resources/" cache-period="365*24*60*60" />
```
Cache-Control : max-age = {specified-max-age} 응답 헤더가 브라우저로 전송된다.

### 정적 콘텐츠의 GZip 압축 사용
응답 압축은 웹 애플리케이션을 더 빠르게 만드는 간단한 방법이다. 최신 브라우저는 모두 GZip압축을 지원한다. 전체 정적 콘텐츠 파일을 보내는 대신, 압축된 파일을 응답으로 보낼 수 있다. 브라우저는 압축을 풀고 정적 콘텐츠를 사용한다. 브라우저는 요청 헤더를 사용해 압축된 내용을 승인할 수 있다. 서버가 지원하면 응답 헤더로 표시되는 압축된 콘텐츠를 전달할 수 있다.
브라우저에서 보낸 요청 헤더는 다음과 같다.
```
Accept-Encoding : gzip, deflate
```

웹 애플리케이션에서 보낸 응답헤더는 다음과 같다.
```
Content-Encoding: gzip
```

다음 단락은 Gzip 리졸버를 추가해 압축된 정적 콘텐츠를 전달하는 방법이다.
```java
registry.addResourceHandler("resources/**")
.addResourceLocations("/static-resources/")
.setCachePeriod(365*24*60*60)
.resourceChain(true)
.addResolver(new GzipResourceResolver())
.addResolver(new PathResourceResolver());
```
* resourceChain(true) : GZip 압축을 사용하려고 하지만 전체 파일을 요청했을 경우 전체 파일 전달로 되돌아가려고 하기 때문에 자원 연결(자원 리졸버의 연결)을 사용한다.
* addResolver(new PathResourceResolver()) : PathResourceResolver는 기본 리졸버다. 구성된 리소스 핸들러와 위치를 기반으로 처리한다.
* addResolver(new GzipResourceResolver()) : GzipResourceResolver는 요청시 Gzip 압축을 가능하게 한다.