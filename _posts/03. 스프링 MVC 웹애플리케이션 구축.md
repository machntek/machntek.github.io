스프링 MVC가 컨트롤러, 핸들러 매핑, 뷰 리졸버, POJO 명령 빈에 대한 역할을 명확하게 정의하면, 의존성 주입 및 자동 와이어링과 같은 모든 핵심 스프링 기능을 사용해 웹 애플리케이션을 간단하게 만들 수 있다. 또한 다중 뷰 기술을 지원하므로 확장이 가능하다.

# 자바 웹 애플리케이션 아키텍처
## 모델1 아키텍처
- JSP 페이지는 브라우저에서 요청을 직접 처리했다.
- JSP 페이지는 간단한 자바 빈을 포함하는 모델을 사용했다.
- 이 아키텍처 스타일의 일부 애플리케이션에서는 JSP가 데이터베이스에 대한 쿼리를 수행했다.
- JSP는 다음에 표시할 페이지인 플로 로직을 처리했다.

이 접근법의 많은 단점중 중요한 단점은 다음과 같다.
- 어려운 관점 분리 : JSP는 데이터 검색, 데이터 표시, 다음에 표시할 페이지(흐름) 결정, 때로는 비즈니스 로직까지도 담당했다.
- 복잡한 JSP: JSP가 많은 로직을 처리했기 때문에 거대하고 유지 관리하기가 어려웠다.

## 모델2 아키텍처
모델2 아키텍처는 여러 책임이 있는 복잡한 JSP와 관련된 복잡성을 해결하기 위해 도입됐다. 이것은 MVC 아키텍처 스타일의 기반을 형성한다. 

모델2 아키텍처는 모델, 뷰 및 컨트롤러 간에 명확한 역할 분리를 제공한다. 이는 유지 관리가 쉬운 애플리케이션을 제공한다.
- 모델 : 뷰를 생성하는 데 사용할 데이터를 나타낸다.
- 뷰 : 모델을 사용해 화면을 렌더링한다.
- 컨트롤러 : 흐름을 제어한다. 브라우저에서 요청을 가져와 모델을 채우고 뷰로 리다이렉션 한다.

## 모델2 프런트 컨트롤러 아키텍처
모델2 아키텍처의 기본버전에서 브라우저의 요청은 다른 서블릿(또는 컨트롤러)에 의해 직접 처리된다.
여러 비즈니스 시나리오에서 요청을 처리하기 전에 서블릿에서 일반적인 몇가지 작업을 수행하려 한다. 예를 들면, 로그인한 사용자가 요청을 실행할 수 있는 권한을 갖고있는지 확인하는 것이다.
이것은 모든 서블릿에서 구현하길 원치않는 공통기능이다. 모델2프론터 컨트롤러 아키텍처에서는 모든 요청이 프론트 컨트롤러라는 단일 컨트롤러로 전달된다.

일반적인 프론트 컨트롤러의 책임은 다음과 같다.
- 어떤 컨트롤러가 요청을 실행할지 결정한다
- 렌더링할 뷰를 결정한다
- 좀 더 일반적인 기능을 추가하는 조항을 제공한다
- 스프링 MVC는 프론트 컨트롤러에서 MVC패턴을 사용한다. 프론트 컨트롤러는 DispatcherServlet이다(뒤에서 설명).

# 기본 플로
스프링 MVC는 모델2 프런트 컨트롤러 아키텍처의 수정된 버전을 사용한다. 이 절에서는 스프링MVC로 일반적인 웹앱 플로 6개를 만든다.
* 플로 1: 뷰가 없는 컨트롤러, 자체적으로 콘텐츠 제공
* 플로 2: 뷰가 있는 컨트롤러(JSP)
* 플로 3: 뷰가 있고, ModelMap을 사용하는 컨트롤러
* 플로 4: 뷰가 있고, ModelAndView를 사용하는 컨트롤러
* 플로 5: 간단한 폼의 컨트롤러
* 플로 6: 벨리데이션이 있는 간단한 폼의 컨트롤러

## 기본 설정
다음 절에서는 웹 애플리케이션에서 스프링 MVC 구성을 이해하는 것부터 시작 한다. 의존성을 관리하기 위해 메이븐을 사용하고 있다. 간단한 웹 애플리케이션을 설정하는 단계는 다음과 같다.
1. 스프링 MVC에 대한 의존성을 추가한다
2. DispatcherServlet을 web.xml에 추가한다.
3. 스프링 애플리케이션 콘텍스트를 생성한다.

### 스프링 MVC에 대한 의존성 추가
**pom.xml**에 스프링 MVC 의존성을 추가하는 것부터 시작한다. 다음 코드는 추가할 의존성을 보여준다. 스프링 BOM을 사용하기 때문에 아티팩트 버전을 지정할 필요가 없다.
```xml
<dependency>
    <groupId>org.springframework</groupId>
    <artifactId>spring-webmvc</artifactId>
</dependency>
```
DispatcherServlet은 프런트 컨트롤러 패턴의구현이다. 스프링 MVC에 대한 요청은 프런트 컨트롤러, 즉 DispatcherServlet에 의해 처리될 것이다.

### DispatcherServlet을 web.xml에 추가
이 기능을 사용하려면 DispatcherServlet을 web.xml에 추가해야 한다. 추가하는 방법을 알아보자.
```xml
<servlet>
    <servlet-name>spring-mvc-dispatcher-servlet</servlet-name>
    <servlet-class>org.springframework.web.servlet.DispatcherServlet</servlet-class>
    <init-param>
        <param-name>contextConfigLocation</param-name>
        <param-value>/WEB-INF/user-web-context.xml</param-value>
    </init-param>
    <load-on-startup>1</load-on-startup>
</servlet>
<servlet-mapping>
    <servlet-name>spring-mvc-dispatcher-servlet</servlet-name>
    <url-pattern>/</url-pattern>
</servlet-mapping>
```
첫번째 부분에서는 서블릿을 정의한다. 콘텍스트 구성 위치인 /WEB-INF/user-web-context.xml도 정의하고 있다. 스프링 콘텍스트는 다음 단계에서 정의할 것이다.
두번째 부분에서는 서블릿 매핑을 정의한다. 여기서는 URL /을 DispatcherServlet에 매핑하고 있다. 따라서 모든 요청은 DispatcherServlet에 의해 처리된다.

### 스프링 콘텍스트 생성
web.xml에 DispatcherServlet이 정의됐으므로 스프링 콘텍스트를 만들 수 있다. 처음에는 구체적인 내용을 실제로 정의하지 않고, 매우 간단한 콘텍스트를 만든다.
```xml
<beans>
    <context:component-scan base-package="com.mastering.spring.springmvc" />
    <mvc:annotation-drive />
</beans>
```
com.mastering.spring.springmvc 패키지에 대한 구성 요소 검사를 정의하면, 이 패키지에 모든 빈 및 컨트롤러가 생성되고 오토와이어드 된다.
<mvc:annotation-driven />을 사용하면, 다음과 같이 스프링 MVC가 지원하는 많은 기능에 대한 지원을 초기화 한다.
* 요청 매핑
* 예외 처리
* 데이터 바인딩 및 벨리데이션
* @RequestBody 어노테이션을 사용하는 경우 자동 변환(예:JSON)

이것이 스프링MVC 애플리케이션을 설정하는 데 필요한 모든 설정이다. 이제 첫 번째 플로를 시작할 준비가 됐다.

## 플로 1 - 뷰 없는 간단한 컨트롤러 플로
스프링 MVC 컨트롤러에서 화면에 출력되는 간단한 텍스트를 보여주는 간단한 플로를 시작해보자

### 스프링 MVC 컨트롤러 생성
```JAVA
@Controller
public class BasicController {
    @RequestMapping(value = "/welcome")
    @ResponseBody
    public String welcome() {
        return "welcome to spring MVC";
    }
}
```
* @Controller : 요청 매핑을 포함할 수 있는 스프링 MVC 컨트롤러를 정의한다. URL을 컨트롤러 메서드에 매핑한다.
* @RequestMapping(value="/welcome") : URL /welcome을 welcome 메서드에 매핑하는 것을 정의한다. 브라우저가 /welcome에 요청을 보내면, 스프링 MVC는 welcome 메서드를 실행한다.
* @ResponseBody : 이 특정 콘텍스트에서는 welcome메서드가 반환한 텍스트가 응답 내용으로 브라우저에 전송된다. 특히, @ResponseBody는 REST 서비스의 맥락에서 많은 마법을 수행한다. 이에 대해서는 5장, '스프링 부트로 마이크로 서비스 구축'에서 논의한다.

### 웹 애플리케이션 구동
mvn tomcat7:run 명령을 호출하면 서버를 실행할 수 있다.

### 단위 테스팅
여기서는 스프링 MVC 모킹 프레임워크를 사용해 3장에서 작성할 컨트롤러를 단위 테스트할 것이다. 또한 스프링 MVC 모킹 프레임워크를 사용하기 위해 스프링 테스트 프레임워크에 의존성을 추가한다.
```xml
<dependency>
    <groupId>org.springframework</gorupId>
    <artifactId>spring-test</artifactId>
    <scope>test</scope>
</dependency>
```
여기서는 사용할 접근법은 다음과 같다.
1. 테스트할 컨트롤러 설정하기
2. 테스트 메서드 작성하기

#### 테스트를 위한 컨트롤러 설정
테스트하고자 하는 컨트롤러는 BasicController다. 단위 테스트를 생성하는 관례는 클래스 이름에 접미사로 Test를 붙히는 것이다.
```java
public class BasicControllerTest {
    private MockMvc mockMvc;
    @Before
    public void setup() {
        this.mockMvc = MockMvcBuilder.standaloneSetup(new BasicController()).build();
    }
}
```
* mockMvc : 이 변수는 다른 테스트에서도 사용할 수 있다. 그래서 MockMvc클래스의 인스턴스 변수를 정의한다.
* @Before setup : 이 방법은 모든 테스트 전에 실행돼 MockMvc를 초기화한다.
* MockMvcBuilder.standaloneSetup(new BasicController()).build : 이 코드 라인은 MockMvc 인스턴스를 빌드한다. DispatcherServlet을 초기화해 설정된 컨트롤러인 BasicController로 요청을 처리한다.

#### 테스트 메서드 작성
전체 테스트 메서드는 다음과 같다.
```java
@Test
public void basicTest() throws Exception {
    this.mockMvc
    .perform(get("/welcome")
        .accept(MediaType.parseMediaType("application/html;charset=UTF-8")))
    .andExpect(status().isOk())
    .andExpect( content().contentType("application/html;charset=UTF-8"))
    .andExpect(content().string("Welcome to Spring MVC"));    
}
```
* MockMvc mockMvc.perform : 이 메서드는 요청을 실행하고 체인 호출을 허용하는 ResultActions의 인스턴스를 반환한다. 이 예제에서는 예상한 값을 확인하기 위해 andExpect 호출을 연결한다.
* get("/welcome").accept(MediaType.parseMediaType("applictaion/html;charset=UTF-8")) : 미디어타입이 application/html인 응답을  수신하는 HTTP get 요청을 작성한다.
* andExpect : 이 방법은 예상한 값을 확인하는 데 사용된다. 예상이 맞지 않으면 이 방법은 테스트에 실패한다.
* status().isOk() : ResultMatcher를 사용해 응답상태가 성공적인 요청인지의 여부를 확인한다.(200)
* contentType("application/html;charset=UTF-8") : ResultMatcher를 사용해 응답의 내용 타입이 지정된 대로 있는지 확인한다.
* content().string("Welcome to Spring MVC") : ResultMatcher를 사용해 응답 내용에 지정된 문자열이 들어 있는지 확인한다.


## 플로 2 - 뷰를 가진 간단한 컨트롤러 플로
이전 플로에서는 브라우저에 표시할 텍스트가 컨트롤러에 하드코딩됐다. 브라우저에 표시할 내용은 일반적으로 뷰에서 생성된다. 가장 많이 사용되는 옵션은 JSP다. 여기서는 컨트롤러에서 뷰로 리다이렉션해본다.

### 스프링 MVC 컨트롤러
```java
@Controller
public class BasicViewController {
    @RequestMapping(value="/welcome-view")
    public String welcome() {
        return "welcome";
    }
}
```
* @RequestMapping(value="/welcome-view") : URL /welcome-view 를 매핑한다.
* public String welcome() : 이 메서드에는 @RequestBody 어노테이션이 없다. 따라서 스프링 MVC는 반환된 문자열인 welcome을 뷰와 일치시키려고 시도한다.

### 뷰 생성 - JSP

/src/main/webapp/WEB-INF/views/welcome.jsp
```html
<html>
    <head>
        <title>welcome</title>
    </head>
    <body>
        <p>Welcome!</p>
    </body>
</html>
```
스프링 MVC는 welcome 메서드에서 반환된 문자열을 /WEB-INF/view/welcome.jsp에 있는 실제 JSP로 매핑한다.

#### 뷰 리졸버
뷰 리졸버는 뷰 이름을 실제 JSP페이지로 해석한다. 뷰 리졸버는 스프링 콘텍스트 /WEB-INF/user-web-context.xml에서 구성할 수 있다.
```xml
<bean class="org.springframework.web.servlet.view.InternalResourceViewResolver">
    <property name="prefix">
        <value>/WEB-INF/views/</value>
    </property>
    <property name="suffix">
        <value>.jsp</value>
    </property>
</bean>
```
* org.springframework.web.servlet.view.InternalResourceViewResolver : JSP를 지원하는 뷰 리졸버로, 일반적으로 JstlView가 사용된다. 또한 타일즈(tiles)를 TilesView로 지원한다.
* property prefix/suffix 태그 : 뷰 이름인 welcome은 /WEB-INF/views/welcome.jsp로 해석된다.

### 단위 테스팅
MockMvc 프레임워크의 standalone설정은 DispatcherServlet에 필요한 최소한의 인프라를 생성한다. 뷰 리졸버가 제공되는 경우, 뷰 리솔루션을 실행할 수 있다. 그러나 뷰를 실행하지는 않는다. 따라서 스탠드얼론 설정으로 단위 테스트하는 도중에는 뷰의 내용을 확인할 수 없다. 그러나 올바른 뷰가 전달되는지의 여부는 확인할 수 있다. 이 단위테스트에서는 BasicViewController를 설정하고, /welcome-view에 get 요청을 실행하고, 반환된 뷰 이름이 welcome인지 확인한다. 다음 절에서는 뷰 렌더링을 포함해 통합 테스트를 수행하는 방법을 설명한다. 이 테스트에 관한 한, 뷰 이름을 검증하기 위해 범위를 제한한다.

#### 테스트할 컨트롤러 설정
이 단계는 이전 플로와 매우 유사하다. BasicViewController를 사용해 MockMvc를 인스턴스화한다. 또한 간단한 뷰리졸버를 구성한다.
```java
public class BasicViewControllerTest {
    private MockMvc mockMvc;
    @Before
    public void setup() {
        this.mockMvc = MockMvcBuilders.standaloneSetup(new BasicViewController())
        .setViewResolvers(viewResolver()).build();
    }
    private ViewResolver viewResolver() {
        InternalResourceViewResolver viewReslover = new InternalResourceViewResolver();
        viewResolver.setViewClass(JstlView.class);
        viewResolver.setPrefix("/WEB-INF/jsp/");
        viewResolver.setSuffix(".jsp");
        return viewResolver;
    }
}
```

#### 테스트 메서드 작성
```java
@Test
public void testWelcomeView() throws Exception {
    this.mockMvc
    .perform(get("/welcome-view").accept(MediaType.parseMediaType("application/html;charset=UTF-8")))
    .andExpect(view().name("welcome"));
}
```
* view().name("welcome") : Result Matcher를 사용해 반환된 뷰 이름이 지정된 대로 있는지 확인한다.

## 플로 3 - 모델이 있는 뷰로 전환하는 컨트롤러
일반적으로 뷰를 생성하려면 일부 데이터를 전달해야 한다. 스프링 MVC 에서는 모델을 사용해 뷰에 데이터를 전달할 수 있다. 이 플로에서는 간단한 속성으로 모델을 설정하고, 그 속성을 뷰에서 사용한다.

### 스프링 MVC 컨트롤러
```java
@Controller
public class BasicModelMapController {
    @RequestMapping(value = "/welcome-model-map")
    public String welcome(ModelMap model) {
        model.put("name", "XYZ");
        return "welcome-model-map";
    }
}
```
* public String welcome(ModelMap model) :  추가된 새로운 파라미터는 ModelMap 모델이다. 스프링 MVC는 모델을 인스턴스화해 이 메서드에서 사용할 수 있도록 한다. 모델에 입력된 속성은 뷰에서 사용할 수 있다.

### 뷰 생성
컨트롤러의 모델에 설정된 모델 속성 이름을 사용해 뷰를 생성해보자.
WEB-INF/views/welcome-model-map.jsp
```jsp
Welcome ${name}! This is coming from a model-map -a JSP
```
* ${name} : EL(Expression Language) 구문을 사용해 모델의 속성에 액세스한다.

### 단위 테스트
이 단위테스트에서는 BasicModelMapController를 설정하고 /welcome-model-map에서 get 요청을 실행해 모델이 예상된 속성을 갖고 있는지, 예상된 뷰 이름이 반환되는지의 여부를 확인해야한다.

#### 테스트할 컨트롤러 설정
```java
this.mockMvc = MockBuilders.standaloneSetup(new BasicModelMapController())
                           .setViewResolvers(viewResolver()).build();
```

#### 테스트 메서드 작성
```java
@Test
public void basicTest() throws Exception {
    this.mockMvc.perform(get("/welcome-mode-map").accept(MediaType.parseMediaType("application/html;charset=UTF-8")))
    .andExpect(model().attribute("name", "XYZ"))
    .andExpect(view().name("welcome-model-map"));   
}
```
* model().attribute("name", "XYZ") : 모델이 지정된 값이 XYZ인 특정 속성 이름을 포함하고 있는지 확인하는 Result Matcher

## 플로 4 - ModelAndView를 사용해 뷰로 전환하는 컨트롤러
이전 플로에서는 뷰 이름을 반환하고 뷰에 사용될 속성으로 모델을 채웠다. 스프링 MVC는 ModelAndView를 사용하는 대체 접근법을 제공한다. 컨트롤러 메서드는 모델의 뷰 이름과 적절한 속성을 사용해 ModelAndView 객체를 반환할 수 있다.

### 스프링 MVC 컨트롤러
```java
@Controller
public class BasicModelViewController {
    @RequestMapping(value = "/welcome-model-view")
    public ModelAndView welcome(ModelMap model) {
        model.put("name", "XYZ");
        return new ModelAndView("welcome-model-view", model);
    }
}
```
* public ModelAndView welcome(ModelMap model) : 반환값은 더 이상 스트링이 아니라 ModelAndView이다.

### 뷰 생성
컨트롤러의 모델에 설정된 모델 속성 이름을 사용해 뷰를 생성해보자
/WEB-INF/views/welcome-model-view.jsp
```jsp
Welcome ${name}! This is coming from a model-view - a JSP
```
### 단위테스팅
이 플로의 단위 테스틍인 이전과 유사하다. 예상된 뷰 이름이 반환되는지 확인해야한다.

## 플로 5 - 폼이 있는 뷰로 전환하는 컨트롤러
사용자의 입력을 캡쳐하기 위한 간단한 폼을 만드는 방법
* 간단한 POJO를 만든다. 여기서는 사용자를 만들 것이므로 POJO를 생성한다.
* 2개의 컨트롤러 메서드를 작성한다. 하나는 폼을 표시하는 메서드, 다른 하나는 폼에 입력된 세부 사항을 캡쳐하는 메서드이다.
* 폼으로 간단한 뷰를 작성한다

### 명령 또는 폼 백엔드 오브젝트 작성
POJO는 일반적으로 자바 빈 규칙에 따라 빈을 나타내는데 사용되며, getters, setters 그리고 인수가 없는 생성자를 가진 프라이빗멤버 변수를 포함하고 있다.
```java
public class User {
    private String uid;
    private String name;
    private String userId;
    private String password;
    private String password2;
    //생성자
    //Getter 와 Setters
    //toString
}
```
* 이 클래스에는 어노테이션 또는 스프링 관련 매핑이 없다. 모든 빈은 폼 백엔드 객체로 작동할 수 있다.
* 폼에 이름, 사용자ID 및 암호를 캡처할 것이다.

### 폼을 표시하는 컨트롤러 메서드
로거를 사용해 간단한 컨트롤러를 만드는 것부터 시작한다.
```java
@Controller
public class UserController {
    private Log logger = LogFactory.getLog(UserController.class);
}
```
다음 메서드를 컨트롤러에 추가해보자
```java
@RequestMapping(value="/create-user", method=reuqestMethod.GET)
public String showCreateUserPage(ModelMap model){
    model.addAttribute("user", new User());
    return "user";
}
```
* model.addAttribute("user", new User()) : 빈 폼 백엔드 객체를 사용해 모델을 설정하는 데 사용된다.

### 폼을 가진 뷰 생성
자바 서버 페이지는 스프링 프레임워크에서 지원하는 뷰 기술중 하나다. 스프링 프레임워크를 사용하면 태그 라이브러리를 제공해 뷰를 JSP로 쉽게 만들 수 있다. 여기에는 다양한 폼 요소에 대한 태그, 바인딩, 벨리데이션, 테마 설정 및 메시지 국제화가 포함된다.
이 예제에서는 스프링 MVC태그 라이브러리와 표준 JSTL 태그 라이브러리의 태그를 사용해 뷰를 생성한다.

/WEB-INF/views/user.jsp
```jsp
<%@ taglib uri="http://java.sun.com/jsp/jstl/core" prefix="c" %>
<%@ taglib uri="http://java.sun.com/jsp/jstl/fmt" prefix="fmt" %>
<%@ taglib uri-"http://www.springframework.org/tags/form" prefix="form" %>
<%@ taglib uri="http://www.springframework.org/tags" prefix="spring" %>
```
처음 두 항목은 JSTL 코어 및 서식 태그 라이브러리용이다. 여기서는 스프링 폼 태그를 광범위하게 사용할 것이고, 태그를 지칭하는 접두사를 제공한다.
```jsp
<form:form method="post" modelAttribute="user">
    <fieldset>
        <form:label path="name">Name</form:label>
        <form:input path="name" type="text" required="required" />
    </fieldset>
</form:form>
```

### 컨트롤러가 폼 제출을 처리하는 메서드 가져오기
사용자가 폼 제출하면 브라우저는 HTTP POST 요청을 전송한다.
```java
@RequestMapping(value="/create-user", method=RequestMethod.POST)
public String addTodo(User user) {
    logger.info("user details " + user);
    return "redirect:list-users";
}
```
* public String addTodo(User user) : 스프링 MVC는 폼의 값을 폼 백엔드 객체에 자동으로 바인딩한다.
* return redirect:list-users : 폼을 제출할 때는 일반적으로 DB의 세부 정보를 저장하고, 사용자를 다른 페이지로 리다이렉트 한다. 여기서는 /list-users로 리다이렉팅한다. 스프링 MVC는 리다이렉트를 사용할 때 상태 302와 함께 HTTP응답을 보낸다. 즉, 새 URL로 리다이렉팅한다. 브라우저는 302응답을 처리할 때 사용자를 새 URL로 리다이렉팅한다. POST / REDIRECT / GET 패턴은 중복 폼 제출 문제에 대한 완벽한 방법은 아니지만, 뷰가 렌더링 된 후에 발생하는 경우의 수를 줄여준다.

### 단위 테스팅
다음 플로에서 밸리데이션을 추가할때 단위테스팅 설명 예정.

## 플로 6 - 이전 플로에 밸리데이션 추가
이전 플로에서는 폼을 추가했지만, 폼 값을 확인하지는 않았다. 폼 내용을 벨리데이트 하는 자바스크립트를 작성할 수는 있지만, 서버에서 벨리데이션을 수행하는것이 안전하다.
스프링 MVC는 빈 벨리데이션 API와의 통합을 제공한다. JSR 303과 JSR 349는 빈 벨리데이션 API(각각 버전 1.0과 1.1)에 대한 스펙을 정의한다. 그리고 하이버네이트 벨리데이터는 레퍼런스 구현체다.

### 하이버네이트 벨리데이터 의존성
프로젝트 pom.xml에 하이버네이트 벨리데이터를 추가한다.
```xml
<dependency>
    <groupId>org.hibernate</groupId>
    <artifactId>hibernate-validator</artifactId>
    <version>5.0.2.Fianl</version>
</dependency>
```

### 빈에 대한 간단한 검증
빈 벨리데이션 API는 빈 속성에 지정할 수 있는 여러 가지 벨리데이션을 지정한다.

User클래스
```java
@Size(min = 6, message = "Enter at least 6 characters")
private String name; 
@Size(min = 6, message = "Enter at least 6 characters")
private String userId; 
@Size(min = 8, message = "Enter at least 6 characters")
private String password; 
@Size(min = 8, message = "Enter at least 6 characters")
private String password2; 
```
* @Size(min = 6, message = "Enter at least 6 characters") : 이 필드는 최소 여섯자 이상이어야 한다. 밸리데이션을 통과하지 못하면 메시지 속성의 텍스트가 벨리데이션 에러 메시지로 사용된다.

빈 벨리데이션을 사용해 수행할 수 있는 다른 벨리데이션은 다음과 같다.
* @NotNull
* @Size(min=5, max=50)
* @Past : 과거의 날짜여야 한다
* @Future : 미래의 날짜여야 한다
* @Pattern : 제공된 정규 표현식과 일치해야 한다
* @Max : 필드의 최대값
* @Min : 필드의 최솟값

이제 컨트롤러 메서드를 가져와 폼을 벨리데이트 하는데 집중하자.
```java
@RequestMapping(value = "/create-user-with-validation", method=RequestMethod.POST)
public String addTodo(@Valid User user, BindingResult result) {
    if(result.hasErrors()) {
        return "user";
    }
    logger.info("user details " + user);
    return "redirect:list-users";
}
```
* public String addTodo(@Valid User user, BindingResult result) : @Valid 어노테이션이 사용되면, 스프링 MVC는 빈을 벨리데이트 한다. 벨리데이션 결과는 BindingResult 인스턴스 결과에서 사용할 수 있다.
* if(result.hasErrors()) : 벨리데이션에 에러가 있는지 확인한다.

벨리데이션 에러가 발생할 경우에는 벨리데이션 메시지를 표시하기 위해 user.jsp를 수정해야 한다.
```jsp
    <fieldset>
        <form:label path="name">Name</form:label>
        <form:input path="name" type="text" required="required" />
        <form:errors path="name" cssClass="text-warning" />
    </fieldset>
```
* <form:errors path="name" cssClass="text-warning" /> : 경로에 지정된 필드 이름과 관련된 오류를 표시하는 스프링 폼 태그다. 벨리데이션 에러를 표시하는 데 사용되는 css클래스를 지정할 수도 있다.

### 커스텀 벨리데이션
@AssertTrue 어노테이션을 사용해 좀 더 복잡한 커스텀 벨리데이션을 구현할 수 있다.
다음은 User 클래스에 추가된 예제 메서드 목록이다.
```java
@AssertTrue(message = "Password fields not match")
private boolean isValid() {
    return this.password.equals(this.password2);
}
```
@AssertTrue(message = "Password fields not match") 는 벨리데이션이 실패했을 경우에 표시할 메시지다. 이런 식으로 다중 필드의 복잡한 벨리데이션 로직을 구현할 수 있다.

### 단위 테스팅
이 부분에 대한 단위 테스팅은 벨리데이션 에러를 확인하는데 중점을 둔다. 여기서는 4개의 벨리데이션 에러를 확인하는 빈 폼에 대한 테스트를 작성할 것이다.

#### 컨트롤러 설정
```java
this.mockMvc = MockMvcBuilders.standaloneSetup(new UserValidationController()).build();
```

#### 테스트 메서드
```java
@Test
public void basicTest_WithAllValidationErrors() throws Exception {
    this.mockMvc.perform(post("/create-user-with-validation").accetp(MediaType.parseMediaType("application/html;charset=UTF-8")))
    .andExpect(status().isOk())
    .andExpect(model().errorCount(4))
    .andExpect(model().attributeHasFieldErrorCode("user","name","Size"));
}
```
* post("/create-user-with-validation") : 요청파라미터를 전달하지 않으므로 모든 속성은 null이다. 이경우, 벨리데이션 에러가 발생한다.
* model().errorCount(4) : 모델에 4개의 벨리데이션 에러가 있는지 점검한다.
* model().attributeHasFieldErrorcode("user", "name", "Size") : user 속성에 Size라는 벨리데이션 에러가 있는 name필드가 있는지 확인한다.

# 스프링 MVC의 개요

## 중요 기능
* 각 객체에 대해 잘 정의된 독립적인 역할을 가진 느슨하게 결합된 아키텍처다.
* 유연한 컨트롤러 메서드 정의다. 컨트롤러 메서드는 다양한 범위의 파라미터와 반환값을 가질 수 있다. 이는 프로그래머가 자신의 필요에 맞는 정의를 선택할 수 있는 유연성을 제공한다.
* 도메인 객체를 폼 백엔드 객체로 재사용할 수 있다. 별도의 서식 객체를 가져야할 필요성이 줄어든다
* 현지화를 지원하는 태그 라이브러리(스프링, 스프링-폼)가 내장돼있다.
* 모델은 키-값 쌍과 함께 해시맵을 사용한다. 여러 뷰 기술과의 통합을 허용한다.
* 유연한 바인딩이다. 바인딩하는 동안 불일치되는 타입은 런타임에러대신 벨리데이션 에러로 해결할 수 있다.
* 단위테스트 컨트롤러에 모크 MVC 프레임워크가 포함돼있다.

## 어떻게 작동할까?
예제 플로를 살펴보고, 플로 실행과 관련된 여러 가지 단계를 이해해보자. 여기서는 플로4를 통해 ModelAndView를 반환할 것이다. 플로 4의 URL은 http://localhost:8080/welcome-model-view다. 다른 단계는 다음과 같다.
1. 브라우저는 특정 URL에 요청을 보낸다. DispatcherServlet은 모든 요청을 처리하는 프런트 컨트롤러다. 그래서 DispatcherServlet이 요청을 받는다.
2. Dispatcher Servleet은 URI를 보고, 이를 처리하기 위해 올바른 컨트롤러를 식별해야 한다. 올바른 컨트롤러를 찾는데 도움을 주기 위해 핸들러 매핑과 통신한다.
3. 핸들러 매핑은 요청을 처리하는 특정 핸들러 메서드(예:BasicModelViewController의 welcome메서드)를 반환한다.
4. DispatcherServlet은 특정 핸들러메서드(public ModelAndView welcome(ModelMap model))를 호출한다.
5. 핸들러 메서드는 모델과 뷰를 반환한다. 이 예제에서는 ModelAndView 객체가 반환된다.
6. DispatcherServlet에는 논리적 뷰 이름(ModelAndView에서 가져온 것, 이 예에서는 welcome-model-view)이 있다. 따라서 물리적 뷰 이름을 결정하는 방법을 알아내야 한다. 사용할 수 있는 뷰 리졸버가 있는지의 여부를 확인한다. 설정된 뷰 리졸버를 찾는다(org.springframework.web.servlet.view.InternalResourceViewResolver). 뷰 리졸버를 호출해 논리적 뷰 이름(이 예제에서는 welcome-model-view)을 입력으로 제공한다.
7. 뷰 리졸버는 논리적 뷰 이름을 물리적 뷰 이름에 매핑하는 로직을 실행한다. 이 예에서는 welcome-model-view는 /WEB-INF/views/welcome-model-view.jsp로 변환된다.
8. DispatcherServlet은 뷰를 실행한다. 또한 뷰에서 모델을 사용할 수 있게 한다.
9. 뷰는 DispatcherServlet으로 보내질 내용을 반환한다.
10. DispatcherServlet은 응답을 다시 브라우저로 보낸다.


# 스프링 MVC의 핵심 개념
